<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foojolt</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foojolt.github.io/"/>
  <updated>2016-02-29T11:36:42.000Z</updated>
  <id>http://foojolt.github.io/</id>
  
  <author>
    <name>foojolt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OAuth详细解读</title>
    <link href="http://foojolt.github.io/2016/02/29/oauth/"/>
    <id>http://foojolt.github.io/2016/02/29/oauth/</id>
    <published>2016-02-29T08:07:14.000Z</published>
    <updated>2016-02-29T11:36:42.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;OAuth-解读&quot;&gt;&lt;a href=&quot;#OAuth-解读&quot; class=&quot;headerlink&quot; title=&quot;OAuth 解读&quot;&gt;&lt;/a&gt;OAuth 解读&lt;/h3&gt;&lt;p&gt;本文包含OAuth协议的形象化描述，包括各个阶段请求的细节，包括参数解释（state, nonce, timestamp等）&lt;/p&gt;
&lt;p&gt;来自维基百科:&lt;a href=&quot;https://zh.wikipedia.org/wiki/OAuth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OAuth&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/oauth-flow.png&quot; alt=&quot;oauth-flow&quot;&gt;&lt;/p&gt;
&lt;p&gt;OAuth协议的参与方：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Resource Server是RS(Resource Server)，保存了client希望获得的资源（这里是用户在Google的消息流）&lt;/p&gt;
&lt;p&gt;Google Authorization Server是AS（Authorization Server），即授权服务器。Client访问RS，需要得到AS的授权凭证（即access token）&lt;/p&gt;
&lt;p&gt;Facebook是Client，希望得到Alice的同意，来访问其在Google的资源（即Alice的消息流）&lt;/p&gt;
&lt;p&gt;Alice 是Resource Owner(资源所有者)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;步骤解读：&lt;br&gt;(1)Facebook在自己的网页上放置一个链接，地址是 accounts.google.com/o/oauth2/oauth….用户单击后，跳转到Google AS页面（也可能是弹窗），注意带上了以下参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redirect_uri:用户授权后，返回的Facebook页面&lt;/p&gt;
&lt;p&gt;client_id: Facebook在Google侧注册的client_id，Facebook还保存有对应的client_secret。后面会用到。&lt;/p&gt;
&lt;p&gt;state: Client的会话Id，不同的用户在Facebook点击上文的链接，产生不同的state字符串。防止恶意用户伪造一个URL，诱导其他用户去点击。即CSRF（cross site request forgery跨站请求伪造）攻击。详见:&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;跨站请求伪造&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;response_type: 一般是code，表示 Authorization_code，即授权码&lt;/p&gt;
&lt;p&gt;scope: 资源类型，这里指用户的消息流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）（3）用户在Google的页面，同意了Facebook获取消息流的请求。当然如果用户没有在Google登录，则需要先登录。之后，Google通过302返回码，引导Alice的浏览器，访问 www.facebook.com/?code=xx&amp;amp;state=xx，参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;code: 即 Authorization_code用户的授权码，表示facebook已经得到用户的授权。&lt;/p&gt;
&lt;p&gt;state: 即步骤1中，facebook生成的state， google AS原样返回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（4）(5)步骤2的请求到了Facebook后台，Facebook后台向google AS发起了一个获取 access_token的请求，包含过期时间等信息。注意这次不是通过Alice的浏览器了。参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;code: 即步骤2得到的用户授权码。&lt;/p&gt;
&lt;p&gt;redirect_uri: 即步骤1的跳转url。这个仅作校验之用。&lt;/p&gt;
&lt;p&gt;client_id &amp;amp; client_secret: Facebook在Google AS注册得到的凭证&lt;/p&gt;
&lt;p&gt;grant_type：授权类型。往往由AS设置的固定值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(6) 经过了以上步骤，终于，Facebook可以问google的RS请求用户Alice的消息流了。回顾一下，首先，通过 Authorization_code的方式，Facebook首先得到了Alice的许可。然后通过 access_token的方式，Facebook又得到了Google AS的许可（提供了 Authorization_code以及 client_id, client_secret）。&lt;/p&gt;
&lt;p&gt;在更复杂的实现中，为了防止请求重放攻击，在有些请求的参数中，又加入了nonce和timestamp：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nonce: 即 number [used only] once，就是只能用一次的随机数。可以有效防止重复攻击。但服务器端要记住所有已经用过的nonce，这对服务器来说，是个不小的负担。&lt;/p&gt;
&lt;p&gt;timestamp: 时间戳，一般只从1970年开始的毫秒数。和 nonce一起用，用于减轻服务器保存nonce的负担。服务器端会保留一个较旧的 timestamp_start，如果请求中的 timestamp 比 timestamp_start 还小，服务器直接拒绝请求，因为更早的nonce列表被服务器删除了，无法校验是否重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/seccloud/article/details/8192707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;帮你深入理解OAuth2.0协议&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://oauth.net/core/1.0/#nonce&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;oauth core 1.0 - nonce&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;OAuth-解读&quot;&gt;&lt;a href=&quot;#OAuth-解读&quot; class=&quot;headerlink&quot; title=&quot;OAuth 解读&quot;&gt;&lt;/a&gt;OAuth 解读&lt;/h3&gt;&lt;p&gt;本文包含OAuth协议的形象化描述，包括各个阶段请求的细节，包括参数解释（state, no
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二度人脉算法</title>
    <link href="http://foojolt.github.io/2016/02/29/second-relation-algorithm/"/>
    <id>http://foojolt.github.io/2016/02/29/second-relation-algorithm/</id>
    <published>2016-02-29T03:46:14.000Z</published>
    <updated>2016-02-29T03:46:48.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,weight&lt;br&gt;b,a,weight&lt;br&gt;…&lt;br&gt;注：关系是有向的。a,b,weight 表示 a可以联系到b，联系的强度是weight。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,c,b&lt;br&gt;b,d,c&lt;br&gt;x,y,(m1,m2,…)&lt;br&gt;…&lt;br&gt;注：包含所有二度人脉；x,y,(m1,m2) 表示y是x的二度人脉，中间人可以是多个(m1,m2,…)，按权重降序排列。二度人脉的权重是：(r1 &lt;em&gt; weight(x, m1) + r2 &lt;/em&gt;  weight(m1, y)) / 2，如： r1 = 1, r2 = 1/2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;a href=&quot;#算法1：用逆向关系做中间数据&quot; class=&quot;headerlink&quot; title=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;/a&gt;算法1：用逆向关系做中间数据&lt;/h3&gt;&lt;p&gt;mapreduce实现：启动两个mapreduce job。&lt;br&gt;job1 map:&lt;br&gt;将每一条关系数据，输出为正向和逆向两条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;注： F为 forward，B为 backward。中间数据大小翻倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job1 reduce:&lt;br&gt;聚合每个个体的正向和逆向关系列表：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;注：每个个体一行，key为个体，value为两个数组：包括正向和逆向关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 map:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b,[ (c, weight) ]&lt;br&gt;…&lt;br&gt;注：主要是将两个数组的元素两两配对，weight加权平均，并输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 reduce:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,[ (c, weight) ]&lt;br&gt;a,b,[ (z, weight) ]&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b, [ (c, weight), (z, weight) ]&lt;br&gt;注：排序在reduce节点内做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特点：数据量膨胀一倍，适合离线计算。根据需要，可进一步放到NoSql中快速查询，或者对目标个体做索引，方便人脉搜索。&lt;/p&gt;
&lt;h3 id=&quot;在线计算&quot;&gt;&lt;a href=&quot;#在线计算&quot; class=&quot;headerlink&quot; title=&quot;在线计算&quot;&gt;&lt;/a&gt;在线计算&lt;/h3&gt;&lt;p&gt;需求是，实时计算某个体的二度人脉。&lt;br&gt;使用分布式的图计算算法，如Spark GraphX，首先加载点和边的数据。&lt;br&gt;从起点个体出发，向它的一度关系个体发送消息并聚合，得到一度人脉个体列表。在从所有这些一度列表出发，发送消息到所有二度个体并聚合。实际上是一种广度优先的算法。&lt;br&gt;参考：&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages%5BA%5D((EdgeContext%5BVD,ED,A%5D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Graph.aggregateMessages &lt;/a&gt;%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag%5BA%5D):VertexRDD%5BA%5D)&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/BreathL/blog/75112&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;海量数据的二度人脉挖掘算法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/graphx-programming-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphX Programming Guide&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,w
    
    </summary>
    
    
  </entry>
  
</feed>
