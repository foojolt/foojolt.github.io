<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foojolt</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foojolt.github.io/"/>
  <updated>2016-02-29T03:46:48.000Z</updated>
  <id>http://foojolt.github.io/</id>
  
  <author>
    <name>foojolt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二度人脉算法</title>
    <link href="http://foojolt.github.io/2016/02/29/second-relation-algorithm/"/>
    <id>http://foojolt.github.io/2016/02/29/second-relation-algorithm/</id>
    <published>2016-02-29T03:46:14.000Z</published>
    <updated>2016-02-29T03:46:48.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,weight&lt;br&gt;b,a,weight&lt;br&gt;…&lt;br&gt;注：关系是有向的。a,b,weight 表示 a可以联系到b，联系的强度是weight。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,c,b&lt;br&gt;b,d,c&lt;br&gt;x,y,(m1,m2,…)&lt;br&gt;…&lt;br&gt;注：包含所有二度人脉；x,y,(m1,m2) 表示y是x的二度人脉，中间人可以是多个(m1,m2,…)，按权重降序排列。二度人脉的权重是：(r1 &lt;em&gt; weight(x, m1) + r2 &lt;/em&gt;  weight(m1, y)) / 2，如： r1 = 1, r2 = 1/2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;a href=&quot;#算法1：用逆向关系做中间数据&quot; class=&quot;headerlink&quot; title=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;/a&gt;算法1：用逆向关系做中间数据&lt;/h3&gt;&lt;p&gt;mapreduce实现：启动两个mapreduce job。&lt;br&gt;job1 map:&lt;br&gt;将每一条关系数据，输出为正向和逆向两条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;注： F为 forward，B为 backward。中间数据大小翻倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job1 reduce:&lt;br&gt;聚合每个个体的正向和逆向关系列表：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;注：每个个体一行，key为个体，value为两个数组：包括正向和逆向关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 map:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b,[ (c, weight) ]&lt;br&gt;…&lt;br&gt;注：主要是将两个数组的元素两两配对，weight加权平均，并输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 reduce:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,[ (c, weight) ]&lt;br&gt;a,b,[ (z, weight) ]&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b, [ (c, weight), (z, weight) ]&lt;br&gt;注：排序在reduce节点内做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特点：数据量膨胀一倍，适合离线计算。根据需要，可进一步放到NoSql中快速查询，或者对目标个体做索引，方便人脉搜索。&lt;/p&gt;
&lt;h3 id=&quot;在线计算&quot;&gt;&lt;a href=&quot;#在线计算&quot; class=&quot;headerlink&quot; title=&quot;在线计算&quot;&gt;&lt;/a&gt;在线计算&lt;/h3&gt;&lt;p&gt;需求是，实时计算某个体的二度人脉。&lt;br&gt;使用分布式的图计算算法，如Spark GraphX，首先加载点和边的数据。&lt;br&gt;从起点个体出发，向它的一度关系个体发送消息并聚合，得到一度人脉个体列表。在从所有这些一度列表出发，发送消息到所有二度个体并聚合。实际上是一种广度优先的算法。&lt;br&gt;参考：&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages%5BA%5D((EdgeContext%5BVD,ED,A%5D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Graph.aggregateMessages &lt;/a&gt;%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag%5BA%5D):VertexRDD%5BA%5D)&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/BreathL/blog/75112&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;海量数据的二度人脉挖掘算法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/graphx-programming-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphX Programming Guide&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,w
    
    </summary>
    
    
  </entry>
  
</feed>
