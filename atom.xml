<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foojolt</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foojolt.github.io/"/>
  <updated>2016-03-02T08:50:03.000Z</updated>
  <id>http://foojolt.github.io/</id>
  
  <author>
    <name>foojolt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDFS 理解</title>
    <link href="http://foojolt.github.io/2016/03/02/hdfs-flow/"/>
    <id>http://foojolt.github.io/2016/03/02/hdfs-flow/</id>
    <published>2016-03-02T02:30:14.000Z</published>
    <updated>2016-03-02T08:50:03.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;主要特点&quot;&gt;&lt;a href=&quot;#主要特点&quot; class=&quot;headerlink&quot; title=&quot;主要特点&quot;&gt;&lt;/a&gt;主要特点&lt;/h3&gt;&lt;p&gt;廉价机器组成集群，系统具备容错能力&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HDFS 集群中数据节点可能随时宕机，主节点能通过心跳及时发现故障，并启动文件块恢复。主节点对内存要求高，因为元数据信息要保存在内存中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;适合批量分块、一次写多次读&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不像POSIX文件系统，常常流式从头读到尾，随机修改内容等，HDFS文件只支持追加到末尾。单次读取延时高，但批量任务可以通过多个block分块并发读取提高吞吐量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将运算移到数据的附近，而不是相反&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HDFS数据节点往往承担计算任务，调度器会就近分配计算任务。比如MapReduce任务，每个Map任务最好在分片本地进行。但Reduce还是免不了要移动中间数据到计算节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;HDFS-架构图&quot;&gt;&lt;a href=&quot;#HDFS-架构图&quot; class=&quot;headerlink&quot; title=&quot;HDFS 架构图&quot;&gt;&lt;/a&gt;HDFS 架构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/hdfsarchitecture.png&quot; alt=&quot;Hdfs architecture&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Namenode&quot;&gt;&lt;a href=&quot;#Namenode&quot; class=&quot;headerlink&quot; title=&quot;Namenode&quot;&gt;&lt;/a&gt;Namenode&lt;/h3&gt;&lt;p&gt;Namenode保存元数据信息，具体回答两个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;filename-&amp;gt;block sequence (namespace) 文件由哪些block组成&lt;/li&gt;
&lt;li&gt;block-&amp;gt;machinelist (“inodes”) 这些block保存在哪些机器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;namespace信息就是一颗文件树，所有数据放到内存中，接受各种增删改查的请求； inodes 信息可能由于故障恢复、Balance等操作发生变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Namenode的启动过程&quot;&gt;&lt;a href=&quot;#Namenode的启动过程&quot; class=&quot;headerlink&quot; title=&quot;Namenode的启动过程&quot;&gt;&lt;/a&gt;Namenode的启动过程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;读取fsimage并构造内存版本的元数据信息&lt;/li&gt;
&lt;li&gt;读取editlog，并应用可能的元数据修改&lt;/li&gt;
&lt;li&gt;写新的 checkpoint (fsimage’ + editlog)&lt;/li&gt;
&lt;li&gt;维持在安全模式下（可读，拒绝增删改），直到收到足够多的、来自Datanode的block报告&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;启动过程可能存在的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;editlog太多，导致合并花费时间很长；于是社区开发了 secondary-namenode 来定期合并editlog，生成新的fsimage。社区有另外一种叫法： checkpoint-namenode。这不是一个高可用（HA）方案。&lt;br&gt;&lt;img src=&quot;../images/secondary-namenode.png&quot; alt=&quot;secondary-namenode&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fsimage太大，内存装不下。hdfs federation分卷可以解决这个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Namenode-高可用方案&quot;&gt;&lt;a href=&quot;#Namenode-高可用方案&quot; class=&quot;headerlink&quot; title=&quot;Namenode 高可用方案&quot;&gt;&lt;/a&gt;Namenode 高可用方案&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;../images/hdfs-ha.png&quot; alt=&quot;hdfs-ha&quot;&gt;&lt;br&gt;这个方案的核心：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依赖共享存储来同步写操作。一般认为高端存储的可靠性要高于服务器。但这个也是单点。&lt;/li&gt;
&lt;li&gt;DN同时向Active和Standby NN汇报块状态&lt;/li&gt;
&lt;li&gt;依赖Zeekeeper来实现主备切换。FailoverController是单独的进程，监控NN状态&lt;/li&gt;
&lt;li&gt;防&lt;a href=&quot;http://en.wikipedia.org/wiki/Split-brain_`(computing`&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;脑裂&lt;/a&gt;)措施：共享存储只支持来自一个NN的更新操作；DN只执行来自一个NN的更新命令；Client只同时跟一个NN通信&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Hdfs-federation&quot;&gt;&lt;a href=&quot;#Hdfs-federation&quot; class=&quot;headerlink&quot; title=&quot;Hdfs federation&quot;&gt;&lt;/a&gt;Hdfs federation&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;../images/hdfs-federation.jpg&quot; alt=&quot;Hdfs federation&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个方案的核心：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就像Linux文件系统一样，多个NN可以挂在不同的子目录下，各自负责该子目录下的元数据管理；彼此独立。&lt;/li&gt;
&lt;li&gt;多个NN共享DN的块存储。DN可向多个NN汇报块状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;HDFS文件读过程&quot;&gt;&lt;a href=&quot;#HDFS文件读过程&quot; class=&quot;headerlink&quot; title=&quot;HDFS文件读过程&quot;&gt;&lt;/a&gt;HDFS文件读过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/hdfs-read.png&quot; alt=&quot;Hdfs read&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;HDFS文件写过程&quot;&gt;&lt;a href=&quot;#HDFS文件写过程&quot; class=&quot;headerlink&quot; title=&quot;HDFS文件写过程&quot;&gt;&lt;/a&gt;HDFS文件写过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/hdfs-write.png&quot; alt=&quot;Hdfs write&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/apache/hadoop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hadoop源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zh.hortonworks.com/blog/understanding-namenode-startup-operations-in-hdfs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;understanding-namenode-startup-operations-in-hdfs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/hadoop-2-0-namenode-ha-federation-practice-zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;namenode ha &amp;amp; federation&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要特点&quot;&gt;&lt;a href=&quot;#主要特点&quot; class=&quot;headerlink&quot; title=&quot;主要特点&quot;&gt;&lt;/a&gt;主要特点&lt;/h3&gt;&lt;p&gt;廉价机器组成集群，系统具备容错能力&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HDFS 集群中数据节点可能随时宕机，主节点能通
    
    </summary>
    
    
      <category term="hadoop" scheme="http://foojolt.github.io/tags/hadoop/"/>
    
      <category term="hdfs" scheme="http://foojolt.github.io/tags/hdfs/"/>
    
  </entry>
  
  <entry>
    <title>hadoop 端口解读</title>
    <link href="http://foojolt.github.io/2016/03/01/hadoop-ports/"/>
    <id>http://foojolt.github.io/2016/03/01/hadoop-ports/</id>
    <published>2016-03-01T09:12:14.000Z</published>
    <updated>2016-03-02T03:27:00.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;NameNode&quot;&gt;&lt;a href=&quot;#NameNode&quot; class=&quot;headerlink&quot; title=&quot;NameNode&quot;&gt;&lt;/a&gt;NameNode&lt;/h3&gt;&lt;p&gt;8020或9000&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;NameNode RPC端口，为client提供元数据服务等。&lt;br&gt;涉及：NamenodeProtocols将很多接口合在一起，包括 ClientProtocol,DatanodeProtocol（和datanode交互）等&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;50070&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;NameNode对外暴露的http端口&lt;/li&gt;
&lt;li&gt;通过浏览器查看NameNode状态，datanode列表，浏览hdfs文件系统等&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Datanode&quot;&gt;&lt;a href=&quot;#Datanode&quot; class=&quot;headerlink&quot; title=&quot;Datanode&quot;&gt;&lt;/a&gt;Datanode&lt;/h3&gt;&lt;p&gt;50010&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Datanode RPC数据库传输接口，dn的数据块通过这个端口进出。涉及：hdfs.protocol.ClientProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;50020&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Datanode元数据操作端口，比如namenode可以强制datanode立即汇报block信息，以及升级时发shutdown消息给datanode。涉及：ClientDatanodeProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ResourceManager&quot;&gt;&lt;a href=&quot;#ResourceManager&quot; class=&quot;headerlink&quot; title=&quot;ResourceManager&quot;&gt;&lt;/a&gt;ResourceManager&lt;/h3&gt;&lt;p&gt;8030&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;调度器端口，ApplicationMaster通过该地址向RM申请资源、释放资源等。涉及：ApplicationMasterProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8031&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ResourceManager 对NodeManager暴露的地址。NodeManager通过该地址向RM汇报心跳，领取任务等。&lt;br&gt;涉及：ResourceTracker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8032&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ResourceManager 对yarn客户端暴露的地址。客户端通过该地址向RM提交应用程序，获取应用状态以及杀死应用程序等。涉及：ApplicationClientProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8033&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RM管理端口 ResourceManager 对管理员暴露的访问地址。管理员通过该地址向RM发送管理命令等。涉及：ResourceManagerAdministrationProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8088&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webui ResourceManager对外http端口。用户可在浏览器中查看yarn任务的状态、队列、任务节点信息等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NodeManager&quot;&gt;&lt;a href=&quot;#NodeManager&quot; class=&quot;headerlink&quot; title=&quot;NodeManager&quot;&gt;&lt;/a&gt;NodeManager&lt;/h3&gt;&lt;p&gt;8040  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RPC端口，用于实现资源本地化。比如mapreduce任务节点必须下载jar包到本地执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;0(随机可用端口）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NodeManager的容器管理端口，主要用于 ApplicationMaster和NodeManager交互，启动、停止分配到的容器。涉及： ContainerManagementProtocol&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8042&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NodeManager 对外暴露的http端口。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;NameNode&quot;&gt;&lt;a href=&quot;#NameNode&quot; class=&quot;headerlink&quot; title=&quot;NameNode&quot;&gt;&lt;/a&gt;NameNode&lt;/h3&gt;&lt;p&gt;8020或9000&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;NameNode R
    
    </summary>
    
    
      <category term="hadoop" scheme="http://foojolt.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>hadoop 常用命令</title>
    <link href="http://foojolt.github.io/2016/03/01/hadoop-cmds/"/>
    <id>http://foojolt.github.io/2016/03/01/hadoop-cmds/</id>
    <published>2016-03-01T09:12:14.000Z</published>
    <updated>2016-03-01T09:38:31.000Z</updated>
    
    <content type="html">&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://hadoop.apache.org/docs/r2.6.1/hadoop-project-dist/hadoop-common/CommandsManual.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hadoop 2.6.1 命令&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://hadoop.apache.org/docs/r2.6.1/hadoop-project-dist/hadoop-common/CommandsManual.html&quot; target=&quot;_blank&quot; rel=&quot;externa
    
    </summary>
    
    
      <category term="hadoop" scheme="http://foojolt.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>5步搭建个人免费博客</title>
    <link href="http://foojolt.github.io/2016/03/01/blog-start/"/>
    <id>http://foojolt.github.io/2016/03/01/blog-start/</id>
    <published>2016-03-01T08:20:14.000Z</published>
    <updated>2016-03-01T08:20:28.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;5步搭建个人免费博客&quot;&gt;&lt;a href=&quot;#5步搭建个人免费博客&quot; class=&quot;headerlink&quot; title=&quot;5步搭建个人免费博客&quot;&gt;&lt;/a&gt;5步搭建个人免费博客&lt;/h3&gt;&lt;p&gt;首先，找到托管博客的地方：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Websites for you and your projects.&lt;/a&gt;&lt;br&gt;涉及内容： github, git。你的博客网站是开源的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到一个静态网站生成器：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;快速、简洁且高效的博客框架&lt;/a&gt;&lt;br&gt;学会常见的命令： hexo new/generate/server等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，学会markdown，一种互联网的博客格式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用 markdown 写第一篇博客, 参考 &lt;a href=&quot;http://wowubuntu.com/markdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown 语法说明 (简体中文版)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;增加评论系统和流量统计&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注册一个&lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多说&lt;/a&gt;帐号，为自己的博客增加免费的评论系统。注册一个&lt;a href=&quot;http://tongji.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度统计&lt;/a&gt;帐号，掌握网站流量信息。找一个&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo的主题&lt;/a&gt;，如 Apollo，可以把多说和百度统计帐号配置进去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，开始博客之旅吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次将自己用markdown写的博客，通过 hexo 转化成静态html，并通过 git push命令发布到 github上。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;5步搭建个人免费博客&quot;&gt;&lt;a href=&quot;#5步搭建个人免费博客&quot; class=&quot;headerlink&quot; title=&quot;5步搭建个人免费博客&quot;&gt;&lt;/a&gt;5步搭建个人免费博客&lt;/h3&gt;&lt;p&gt;首先，找到托管博客的地方：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a h
    
    </summary>
    
    
      <category term="linux" scheme="http://foojolt.github.io/tags/linux/"/>
    
      <category term="bash" scheme="http://foojolt.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>Bash技巧</title>
    <link href="http://foojolt.github.io/2016/03/01/bash-tricks/"/>
    <id>http://foojolt.github.io/2016/03/01/bash-tricks/</id>
    <published>2016-03-01T03:07:14.000Z</published>
    <updated>2016-03-01T08:20:12.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;设置成-VIM-编辑格式&quot;&gt;&lt;a href=&quot;#设置成-VIM-编辑格式&quot; class=&quot;headerlink&quot; title=&quot;设置成 VIM 编辑格式&quot;&gt;&lt;/a&gt;设置成 VIM 编辑格式&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set -o vi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;指定帐号免登录&quot;&gt;&lt;a href=&quot;#指定帐号免登录&quot; class=&quot;headerlink&quot; title=&quot;指定帐号免登录&quot;&gt;&lt;/a&gt;指定帐号免登录&lt;/h3&gt;&lt;p&gt;场景是，我有多台目标Linux机器，每个登录账户不同。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -f bob&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;将在当前目录下，生成 bob, bob.pub两个文件。将 bob.pub的内容，贴到目标机器的 .ssh/authorized_keys 中。&lt;br&gt;登录时，指定 bob 私钥文件的路径即可：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -i ./bob bob@host&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;可选，用 ssh -v .. 调试可能出现的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;设置成-VIM-编辑格式&quot;&gt;&lt;a href=&quot;#设置成-VIM-编辑格式&quot; class=&quot;headerlink&quot; title=&quot;设置成 VIM 编辑格式&quot;&gt;&lt;/a&gt;设置成 VIM 编辑格式&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="linux" scheme="http://foojolt.github.io/tags/linux/"/>
    
      <category term="bash" scheme="http://foojolt.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>Java的Manifest文件</title>
    <link href="http://foojolt.github.io/2016/03/01/java-manifest/"/>
    <id>http://foojolt.github.io/2016/03/01/java-manifest/</id>
    <published>2016-03-01T02:07:14.000Z</published>
    <updated>2016-03-01T08:20:08.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Manifest文件的作用&quot;&gt;&lt;a href=&quot;#Manifest文件的作用&quot; class=&quot;headerlink&quot; title=&quot;Manifest文件的作用&quot;&gt;&lt;/a&gt;Manifest文件的作用&lt;/h3&gt;&lt;p&gt;Manifest，英文是货物清单。在Java中，每个jar包可以包含这么一个清单文件：META-INF/MANIFEST.MF&lt;/p&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working with Manifest Files: The Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的链接中，提到了几种用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置程序入口&lt;/li&gt;
&lt;li&gt;设置classpath&lt;/li&gt;
&lt;li&gt;密封某一个包 （seal package）&lt;/li&gt;
&lt;li&gt;Java Applet&amp;amp;Web Start 安全配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;设置classpath&quot;&gt;&lt;a href=&quot;#设置classpath&quot; class=&quot;headerlink&quot; title=&quot;设置classpath&quot;&gt;&lt;/a&gt;设置classpath&lt;/h3&gt;&lt;p&gt;这个一般是用不着的。只有在classpath太长，比如大于Linux命令行的最大长度，这样java命令就无法执行了。这时可以在 META-INF/MANIFEST.MF 中添加&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class-Path: jar1-name jar2-name directory-name/jar3-name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;密封一个包&quot;&gt;&lt;a href=&quot;#密封一个包&quot; class=&quot;headerlink&quot; title=&quot;密封一个包&quot;&gt;&lt;/a&gt;密封一个包&lt;/h3&gt;&lt;p&gt;密封一个包的意思是，假如你提供了一个tool.jar包，包含一个类com.foo.tool.BigTool，你不希望别人的代码中，使用同样的包名 com.foo.tool，可以这样做：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Name: com/foo/tool&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sealed: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;效果是： 让JVM只能从tool.jar加载com.foo.tool包&lt;/p&gt;
&lt;h3 id=&quot;更新Manifest文件&quot;&gt;&lt;a href=&quot;#更新Manifest文件&quot; class=&quot;headerlink&quot; title=&quot;更新Manifest文件&quot;&gt;&lt;/a&gt;更新Manifest文件&lt;/h3&gt;&lt;p&gt;可以用一下命令获取一个jar包的manifest文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jar xvf foo.jar META-INF/MANIFEST.MF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用文本编辑器修改后，update到jar包中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jar uvf foo.jar META-INF/MANIFEST.MF&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Manifest文件的作用&quot;&gt;&lt;a href=&quot;#Manifest文件的作用&quot; class=&quot;headerlink&quot; title=&quot;Manifest文件的作用&quot;&gt;&lt;/a&gt;Manifest文件的作用&lt;/h3&gt;&lt;p&gt;Manifest，英文是货物清单。在Java中，每个
    
    </summary>
    
    
      <category term="java" scheme="http://foojolt.github.io/tags/java/"/>
    
      <category term="manifest" scheme="http://foojolt.github.io/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>写程序判断闰年</title>
    <link href="http://foojolt.github.io/2016/02/29/leap-year/"/>
    <id>http://foojolt.github.io/2016/02/29/leap-year/</id>
    <published>2016-02-29T09:07:14.000Z</published>
    <updated>2016-03-01T02:02:40.000Z</updated>
    
    <content type="html">&lt;p&gt;今天很特殊，2月29日。写一篇相关的内容：写程序判断闰年&lt;/p&gt;
&lt;h3 id=&quot;简单的问题不简单&quot;&gt;&lt;a href=&quot;#简单的问题不简单&quot; class=&quot;headerlink&quot; title=&quot;简单的问题不简单&quot;&gt;&lt;/a&gt;简单的问题不简单&lt;/h3&gt;&lt;p&gt;闰年:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;四年一闰，百年不闰，四百年再闰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一个版本&quot;&gt;&lt;a href=&quot;#第一个版本&quot; class=&quot;headerlink&quot; title=&quot;第一个版本&quot;&gt;&lt;/a&gt;第一个版本&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is_leap_year&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(year)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; year % &lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; year % &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; year % &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的写法有什么问题？&lt;br&gt;（1） 太长了，不够优雅&lt;br&gt; (2) 应该从4开始判断，再到100，再到400；这样判断的次数就少多了。&lt;/p&gt;
&lt;h3 id=&quot;第二个版本&quot;&gt;&lt;a href=&quot;#第二个版本&quot; class=&quot;headerlink&quot; title=&quot;第二个版本&quot;&gt;&lt;/a&gt;第二个版本&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is_leap_year&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(year)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (year % &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (year % &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (year % &lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;python中的-and-or&quot;&gt;&lt;a href=&quot;#python中的-and-or&quot; class=&quot;headerlink&quot; title=&quot;python中的 and or&quot;&gt;&lt;/a&gt;python中的 and or&lt;/h3&gt;&lt;p&gt;a = x1 and x2 and x3 and …&lt;br&gt;a的值，等于第一个为false的x的值；或者最后一个x的值。&lt;br&gt;b = y1 or y2 or y3 or …&lt;br&gt;a的值，等于第一个为true的y的值；或者最后一个y的值。&lt;/p&gt;
&lt;p&gt;因此：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;and 或 or 表达式的值，不是布尔类型的，和操作数有关&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天很特殊，2月29日。写一篇相关的内容：写程序判断闰年&lt;/p&gt;
&lt;h3 id=&quot;简单的问题不简单&quot;&gt;&lt;a href=&quot;#简单的问题不简单&quot; class=&quot;headerlink&quot; title=&quot;简单的问题不简单&quot;&gt;&lt;/a&gt;简单的问题不简单&lt;/h3&gt;&lt;p&gt;闰年:&lt;/p&gt;
&lt;b
    
    </summary>
    
    
      <category term="python" scheme="http://foojolt.github.io/tags/python/"/>
    
      <category term="闰年" scheme="http://foojolt.github.io/tags/%E9%97%B0%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>OAuth详细解读</title>
    <link href="http://foojolt.github.io/2016/02/29/oauth/"/>
    <id>http://foojolt.github.io/2016/02/29/oauth/</id>
    <published>2016-02-29T08:07:14.000Z</published>
    <updated>2016-03-02T08:50:12.000Z</updated>
    
    <content type="html">&lt;p&gt;本文包含OAuth协议的形象化描述，包括各个阶段请求的细节，包括参数解释（state, nonce, timestamp等）&lt;/p&gt;
&lt;p&gt;来自维基百科:&lt;a href=&quot;https://zh.wikipedia.org/wiki/OAuth&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OAuth&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/oauth-flow.png&quot; alt=&quot;oauth-flow&quot;&gt;&lt;/p&gt;
&lt;p&gt;OAuth协议的参与方：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Resource Server是RS(Resource Server)，保存了client希望获得的资源（这里是用户在Google的消息流）&lt;/p&gt;
&lt;p&gt;Google Authorization Server是AS（Authorization Server），即授权服务器。Client访问RS，需要得到AS的授权凭证（即access token）&lt;/p&gt;
&lt;p&gt;Facebook是Client，希望得到Alice的同意，来访问其在Google的资源（即Alice的消息流）&lt;/p&gt;
&lt;p&gt;Alice 是Resource Owner(资源所有者)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;步骤解读：&lt;br&gt;(1)Facebook在自己的网页上放置一个链接，地址是 accounts.google.com/o/oauth2/oauth….用户单击后，跳转到Google AS页面（也可能是弹窗），注意带上了以下参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redirect_uri:用户授权后，返回的Facebook页面&lt;/p&gt;
&lt;p&gt;client_id: Facebook在Google侧注册的client_id，Facebook还保存有对应的client_secret。后面会用到。&lt;/p&gt;
&lt;p&gt;state: Client的会话Id，不同的用户在Facebook点击上文的链接，产生不同的state字符串。防止恶意用户伪造一个URL，诱导其他用户去点击。即CSRF（cross site request forgery跨站请求伪造）攻击。详见:&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;跨站请求伪造&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;response_type: 一般是code，表示 Authorization_code，即授权码&lt;/p&gt;
&lt;p&gt;scope: 资源类型，这里指用户的消息流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）（3）用户在Google的页面，同意了Facebook获取消息流的请求。当然如果用户没有在Google登录，则需要先登录。之后，Google通过302返回码，引导Alice的浏览器，访问 www.facebook.com/?code=xx&amp;amp;state=xx，参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;code: 即 Authorization_code用户的授权码，表示facebook已经得到用户的授权。&lt;/p&gt;
&lt;p&gt;state: 即步骤1中，facebook生成的state， google AS原样返回&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（4）(5)步骤2的请求到了Facebook后台，Facebook后台向google AS发起了一个获取 access_token的请求，包含过期时间等信息。注意这次不是通过Alice的浏览器了。参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;code: 即步骤2得到的用户授权码。&lt;/p&gt;
&lt;p&gt;redirect_uri: 即步骤1的跳转url。这个仅作校验之用。&lt;/p&gt;
&lt;p&gt;client_id &amp;amp; client_secret: Facebook在Google AS注册得到的凭证&lt;/p&gt;
&lt;p&gt;grant_type：授权类型。往往由AS设置的固定值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(6) 经过了以上步骤，终于，Facebook可以问google的RS请求用户Alice的消息流了。回顾一下，首先，通过 Authorization_code的方式，Facebook首先得到了Alice的许可。然后通过 access_token的方式，Facebook又得到了Google AS的许可（提供了 Authorization_code以及 client_id, client_secret）。&lt;/p&gt;
&lt;p&gt;在更复杂的实现中，为了防止请求重放攻击，在有些请求的参数中，又加入了nonce和timestamp：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nonce: 即 number [used only] once，就是只能用一次的随机数。可以有效防止重复攻击。但服务器端要记住所有已经用过的nonce，这对服务器来说，是个不小的负担。&lt;/p&gt;
&lt;p&gt;timestamp: 时间戳，一般只从1970年开始的毫秒数。和 nonce一起用，用于减轻服务器保存nonce的负担。服务器端会保留一个较旧的 timestamp_start，如果请求中的 timestamp 比 timestamp_start 还小，服务器直接拒绝请求，因为更早的nonce列表被服务器删除了，无法校验是否重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/seccloud/article/details/8192707&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;帮你深入理解OAuth2.0协议&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://oauth.net/core/1.0/#nonce&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;oauth core 1.0 - nonce&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文包含OAuth协议的形象化描述，包括各个阶段请求的细节，包括参数解释（state, nonce, timestamp等）&lt;/p&gt;
&lt;p&gt;来自维基百科:&lt;a href=&quot;https://zh.wikipedia.org/wiki/OAuth&quot; target=&quot;_blank
    
    </summary>
    
    
      <category term="oauth" scheme="http://foojolt.github.io/tags/oauth/"/>
    
  </entry>
  
  <entry>
    <title>二度人脉算法</title>
    <link href="http://foojolt.github.io/2016/02/29/second-relation-algorithm/"/>
    <id>http://foojolt.github.io/2016/02/29/second-relation-algorithm/</id>
    <published>2016-02-29T03:46:14.000Z</published>
    <updated>2016-03-01T02:02:25.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,weight&lt;br&gt;b,a,weight&lt;br&gt;…&lt;br&gt;注：关系是有向的。a,b,weight 表示 a可以联系到b，联系的强度是weight。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目标输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,c,b&lt;br&gt;b,d,c&lt;br&gt;x,y,(m1,m2,…)&lt;br&gt;…&lt;br&gt;注：包含所有二度人脉；x,y,(m1,m2) 表示y是x的二度人脉，中间人可以是多个(m1,m2,…)，按权重降序排列。二度人脉的权重是：(r1 &lt;em&gt; weight(x, m1) + r2 &lt;/em&gt;  weight(m1, y)) / 2，如： r1 = 1, r2 = 1/2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;a href=&quot;#算法1：用逆向关系做中间数据&quot; class=&quot;headerlink&quot; title=&quot;算法1：用逆向关系做中间数据&quot;&gt;&lt;/a&gt;算法1：用逆向关系做中间数据&lt;/h3&gt;&lt;p&gt;mapreduce实现：启动两个mapreduce job。&lt;br&gt;job1 map:&lt;br&gt;将每一条关系数据，输出为正向和逆向两条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;注： F为 forward，B为 backward。中间数据大小翻倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job1 reduce:&lt;br&gt;聚合每个个体的正向和逆向关系列表：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,(b,F,weight)&lt;br&gt;b,(a,B,weight)&lt;br&gt;b,(c,F,weight)&lt;br&gt;c,(b,B,weight)&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;注：每个个体一行，key为个体，value为两个数组：包括正向和逆向关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 map:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,([  (b,F,weight)  ], [] )&lt;br&gt;b,( [(c,F,weight)], [ a,B,weight ] )&lt;br&gt;c,([  (b,B,weight)  ], [])&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b,[ (c, weight) ]&lt;br&gt;…&lt;br&gt;注：主要是将两个数组的元素两两配对，weight加权平均，并输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;job2 reduce:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,[ (c, weight) ]&lt;br&gt;a,b,[ (z, weight) ]&lt;br&gt;…&lt;br&gt;-&amp;gt;&lt;br&gt;a,b, [ (c, weight), (z, weight) ]&lt;br&gt;注：排序在reduce节点内做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特点：数据量膨胀一倍，适合离线计算。根据需要，可进一步放到NoSql中快速查询，或者对目标个体做索引，方便人脉搜索。&lt;/p&gt;
&lt;h3 id=&quot;在线计算&quot;&gt;&lt;a href=&quot;#在线计算&quot; class=&quot;headerlink&quot; title=&quot;在线计算&quot;&gt;&lt;/a&gt;在线计算&lt;/h3&gt;&lt;p&gt;需求是，实时计算某个体的二度人脉。&lt;br&gt;使用分布式的图计算算法，如Spark GraphX，首先加载点和边的数据。&lt;br&gt;从起点个体出发，向它的一度关系个体发送消息并聚合，得到一度人脉个体列表。在从所有这些一度列表出发，发送消息到所有二度个体并聚合。实际上是一种广度优先的算法。&lt;br&gt;参考：&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/api/scala/index.html#org.apache.spark.graphx.Graph@aggregateMessages%5BA%5D((EdgeContext%5BVD,ED,A%5D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Graph.aggregateMessages &lt;/a&gt;%E2%87%92Unit,(A,A)%E2%87%92A,TripletFields)(ClassTag%5BA%5D):VertexRDD%5BA%5D)&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/BreathL/blog/75112&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;海量数据的二度人脉挖掘算法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/graphx-programming-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphX Programming Guide&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法需求&quot;&gt;&lt;a href=&quot;#算法需求&quot; class=&quot;headerlink&quot; title=&quot;算法需求&quot;&gt;&lt;/a&gt;算法需求&lt;/h3&gt;&lt;p&gt;输入的关系数据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a,b,weight&lt;br&gt;b,c,weight&lt;br&gt;c,d,w
    
    </summary>
    
    
      <category term="人脉" scheme="http://foojolt.github.io/tags/%E4%BA%BA%E8%84%89/"/>
    
      <category term="算法" scheme="http://foojolt.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
