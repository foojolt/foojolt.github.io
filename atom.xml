<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>foojolt</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foojolt.github.io/"/>
  <updated>2016-04-14T02:28:33.000Z</updated>
  <id>http://foojolt.github.io/</id>
  
  <author>
    <name>foojolt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://foojolt.github.io/2016/04/14/java-programming-guide/"/>
    <id>http://foojolt.github.io/2016/04/14/java-programming-guide/</id>
    <published>2016-04-14T02:28:33.000Z</published>
    <updated>2016-04-14T02:28:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Java-编程军规&quot;&gt;&lt;a href=&quot;#Java-编程军规&quot; class=&quot;headerlink&quot; title=&quot;Java 编程军规&quot;&gt;&lt;/a&gt;Java 编程军规&lt;/h3&gt;&lt;p&gt;1 public方法参数的合法性检查应由方法本身负责，每个public方法必须保证自己的健壮性。 &lt;/p&gt;
&lt;p&gt;2 调用方法获取返回结果后必须进行有效性校验，以确保后续代码在运行过程中不会抛出异常或产生逻辑错误。 &lt;/p&gt;
&lt;p&gt;3 在进行数据库操作或IO操作时，必须确保资源在使用完毕后得到释放，并且必须确保释放操作在finally中进行。 &lt;/p&gt;
&lt;p&gt;4 对于if…else if…(后续可能有多个else if…)这种类型的条件判断，最后必须包含一个else分支，避免出现分支遗漏，造成错误；每个switch-case语句都必须保证有default，避免出现分支遗漏，造成错误。 &lt;/p&gt;
&lt;p&gt;5 在使用 Timer 或者 ScheduledThreadPoolExecutor 执行周期性任务时，实现Runnable接口必须在方法内捕获异常，避免因为异常抛出导致周期性住务失效，后续不会继续执行。&lt;/p&gt;
&lt;p&gt;6 确定需要覆盖对象equals()方法时，必须同吋覆盖hashCode()方法。 &lt;/p&gt;
&lt;p&gt;7 在进行精确计算时(例如：货币计算)避免使用float和double,浮点数计算都是不精确的，必须使用BigDecimal或者将浮点数运算转换为整型运算。&lt;/p&gt;
&lt;p&gt;8 确保程序不再持有无用对象的引用，避免程序内存泄露。&lt;/p&gt;
&lt;p&gt;9 对象比较必须使用equals方法，而不是”==”。&lt;/p&gt;
&lt;p&gt;10 访问数组、List等容器内的元素时，必须首先检查下标是否越界，以杜绝下标越界异常的发生。&lt;/p&gt;
&lt;p&gt;11 将对象存入HashSet，或作为key存入HashMap（或HashTable）后，必须确保该对象的hashcode值不变，避免因为hashcode值的变化导致不能从容器内删除该对象，进而引起内存泄露的问题。&lt;/p&gt;
&lt;p&gt;12 在编码过程中，必须在适当的位置，以适当的级别打印日志，便于代码出现问题后进行定位分析。例如：方法入口，出口以Debug打印：异常分支使用ERROR,关键参数打印使用INFO。&lt;/p&gt;
&lt;p&gt;13 避免在程序中使用魔鬼数字，必须用有意义的常量来标识。&lt;/p&gt;
&lt;p&gt;14 将字符串转换为数字时必须处理NumberFormatException异常。 &lt;/p&gt;
&lt;p&gt;15 在进行三个字符串（不包含三个）以上的串联操作时必须使用StringBuilder或StringBuffer，禁止使用“+”。&lt;/p&gt;
&lt;p&gt;16 根据应用场景选择最适合的容器，避免因为容器选择不当造成程序性能问题。&lt;/p&gt;
&lt;p&gt;17 必须在进行I/O操作时使用缓存。 &lt;/p&gt;
&lt;p&gt;18 在程序中必须考虑对象重用，避免创建不必要的垃圾对象。 &lt;/p&gt;
&lt;p&gt;19 对多线程访问的变量、方法，必须加锁保护，避免出现多线程并发访问引起的问题。&lt;/p&gt;
&lt;p&gt;20 新起一个线程时，都要使用Thread.setName(“…”)设置线程名。 &lt;/p&gt;
&lt;p&gt;21 线程使用时，要在代码框架中使用线程池，避免创建不可复用的线程。禁止在循环中创建新线程，否则会引起JVM资源耗尽。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-编程军规&quot;&gt;&lt;a href=&quot;#Java-编程军规&quot; class=&quot;headerlink&quot; title=&quot;Java 编程军规&quot;&gt;&lt;/a&gt;Java 编程军规&lt;/h3&gt;&lt;p&gt;1 public方法参数的合法性检查应由方法本身负责，每个public方法必须保证自
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jvm 规范解读</title>
    <link href="http://foojolt.github.io/2016/04/11/jvm-spec/"/>
    <id>http://foojolt.github.io/2016/04/11/jvm-spec/</id>
    <published>2016-04-11T03:07:14.000Z</published>
    <updated>2016-04-14T02:24:32.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h3&gt;&lt;h3 id=&quot;1-1-java简史&quot;&gt;&lt;a href=&quot;#1-1-java简史&quot; class=&quot;headerlink&quot; title=&quot;1.1 java简史&quot;&gt;&lt;/a&gt;1.1 java简史&lt;/h3&gt;&lt;p&gt;讲了java 和 www 动态内容的关系，主要是 java applet技术，理想是安全／跨平台／比c++更简洁。&lt;br&gt;（现在主流浏览器已经放弃了java的支持，包括移动设备的 java 版本，由于android ios设备的普及，开始变成历史；但java平台已经相对成熟，特别是后台应用，到处都能看到java的身影。&lt;/p&gt;
&lt;h3 id=&quot;1-2-jvm介绍&quot;&gt;&lt;a href=&quot;#1-2-jvm介绍&quot; class=&quot;headerlink&quot; title=&quot;1.2  jvm介绍&quot;&gt;&lt;/a&gt;1.2  jvm介绍&lt;/h3&gt;&lt;p&gt;jvm和java语言几乎没什么关联，除了.class文件，这是联系java语言和jvm的桥梁： java 语言编译成.class文件，jvm负责解析。&lt;br&gt;出于安全考虑，jvm规范了.class的内容，任何语言只要编译成规范的.class文件，就可以在jvm中运行。&lt;br&gt;本文介绍的规范，适用java se 8版本。&lt;/p&gt;
&lt;h3 id=&quot;1-3-本书主要内容&quot;&gt;&lt;a href=&quot;#1-3-本书主要内容&quot; class=&quot;headerlink&quot; title=&quot;1.3 本书主要内容&quot;&gt;&lt;/a&gt;1.3 本书主要内容&lt;/h3&gt;&lt;p&gt;2 jvm概览&lt;br&gt;3 java语言编译成字节码&lt;br&gt;4 .class文件格式&lt;br&gt;5 jvm启动，以及类的加载链接初始化&lt;br&gt;6 指令详解&lt;br&gt;7 指令编号&lt;/p&gt;
&lt;h3 id=&quot;2-jvm结构&quot;&gt;&lt;a href=&quot;#2-jvm结构&quot; class=&quot;headerlink&quot; title=&quot;2 jvm结构&quot;&gt;&lt;/a&gt;2 jvm结构&lt;/h3&gt;&lt;p&gt;  实现一个jvm需要做到： 读取.class文件，并正确执行里面的内容。 规范不包含：jvm内存布局，垃圾回收机制，字节码指令编译成机器码等具体实现。&lt;/p&gt;
&lt;h3 id=&quot;2-1-class文件格式&quot;&gt;&lt;a href=&quot;#2-1-class文件格式&quot; class=&quot;headerlink&quot; title=&quot;2.1 .class文件格式&quot;&gt;&lt;/a&gt;2.1 .class文件格式&lt;/h3&gt;&lt;p&gt;.class文件格式是硬件和os无关的，包含类或者接口的描述，甚至包括字节序等信息。&lt;/p&gt;
&lt;h3 id=&quot;2-2-数据类型&quot;&gt;&lt;a href=&quot;#2-2-数据类型&quot; class=&quot;headerlink&quot; title=&quot;2.2 数据类型&quot;&gt;&lt;/a&gt;2.2 数据类型&lt;/h3&gt;&lt;p&gt;和java语言一样，jvm区分：基本类型和引用类型。&lt;br&gt;如果是基本类型，jvm不通过tag或探测方式，而是通过指令本身来区分，如iadd,ladd,fadd,dadd分别用来对int,long,float,double类型求和。&lt;br&gt;jvm支持object。object要么是一个类的实例，要么是一个数组。引用指向object，只能通过引用来传递／操作object，没有其他途径。&lt;/p&gt;
&lt;h3 id=&quot;2-3-基本类型&quot;&gt;&lt;a href=&quot;#2-3-基本类型&quot; class=&quot;headerlink&quot; title=&quot;2.3 基本类型&quot;&gt;&lt;/a&gt;2.3 基本类型&lt;/h3&gt;&lt;p&gt;类别： 数值类型，布尔类型，returnAddress返回地址类型（jvm特有）&lt;/p&gt;
&lt;p&gt;数值类型包括： 整数型和浮点型&lt;br&gt;整数型： byte,short,char,int,long&lt;br&gt;浮点型： float,long&lt;/p&gt;
&lt;p&gt;返回地址类型：指向指令的地址（与java语言无关），主要被jsr, ret, jsr_w等指令用到。&lt;br&gt;比如，ret idx表示，当前帧的idx位置， 有一个returnAddress类型的值，指向完之后，这个returnAddress 将被放入pc寄存器，jvm指令接着从那个地址往下走。&lt;/p&gt;
&lt;p&gt;布尔类型： jvm内部不直接支持bool类型，而是用int类型替代。&lt;br&gt;但是支持bool数组，比如newarray指令，可以指定创建的类型是bool，其实内部也是用byte数组替代（至少oracle是这样的，数组中每个bool占8 bit）&lt;br&gt;jvm编码 true为1， false为0&lt;/p&gt;
&lt;h3 id=&quot;2-4-引用类型&quot;&gt;&lt;a href=&quot;#2-4-引用类型&quot; class=&quot;headerlink&quot; title=&quot;2.4 引用类型&quot;&gt;&lt;/a&gt;2.4 引用类型&lt;/h3&gt;&lt;p&gt;三种引用类型： 对象引用，接口引用，数组引用，分别指向对象实例，实现了某个接口的实例，以及数组实例。&lt;/p&gt;
&lt;p&gt;数组类型，其实是元素类型的一维数组类型。元素类型本身可以是数组类型，以此构成多维数组。&lt;br&gt;多维数组最后那一维，必须是基本类型，类类型，或接口类型。&lt;/p&gt;
&lt;p&gt;null引用，没有类型，因此可以被cast成任何引用类型。jvm对null的内部表示不做规范。&lt;/p&gt;
&lt;h3 id=&quot;2-5-内存区域&quot;&gt;&lt;a href=&quot;#2-5-内存区域&quot; class=&quot;headerlink&quot; title=&quot;2.5 内存区域&quot;&gt;&lt;/a&gt;2.5 内存区域&lt;/h3&gt;&lt;p&gt;两个级别的内存区域：&lt;br&gt;jvm级别的，在jvm启动时创建，jvm销毁时回收；&lt;br&gt;线程级别的，线程创建时分配，线程销毁时回收&lt;/p&gt;
&lt;h3 id=&quot;2-5-1-pc-寄存器&quot;&gt;&lt;a href=&quot;#2-5-1-pc-寄存器&quot; class=&quot;headerlink&quot; title=&quot;2.5.1 pc 寄存器&quot;&gt;&lt;/a&gt;2.5.1 pc 寄存器&lt;/h3&gt;&lt;p&gt;每个线程都有自己的program count寄存器，在任何一个时间点， 线程总是在执行某个方法的代码，叫做当前方法。 如果不是本地方法，pc存的是jvm指令的地址； 线程执行本地方法是，pc的值未知。&lt;/p&gt;
&lt;h3 id=&quot;2-5-2-jvm栈&quot;&gt;&lt;a href=&quot;#2-5-2-jvm栈&quot; class=&quot;headerlink&quot; title=&quot;2.5.2 jvm栈&quot;&gt;&lt;/a&gt;2.5.2 jvm栈&lt;/h3&gt;&lt;p&gt;线程创建时，会同步创建属于自己的栈空间（stack），栈用来存放帧（frame）。&lt;br&gt;由于java的栈只支持压栈和退栈两种操作，因此可以是不连续的，可以在堆上分配。&lt;/p&gt;
&lt;p&gt;具体的jvm实现时，栈的大小可以固定(但每个线程可以配置不同值)，也可以自由增长和收缩。&lt;/p&gt;
&lt;p&gt;异常相关：&lt;br&gt;StackOverflowError: 栈的大小固定，但计算时超出该大小&lt;br&gt;OutOfMemoryError: 栈空间可以自由增长，但超出了总内存限制&lt;/p&gt;
&lt;h3 id=&quot;2-5-3-堆&quot;&gt;&lt;a href=&quot;#2-5-3-堆&quot; class=&quot;headerlink&quot; title=&quot;2.5.3 堆&quot;&gt;&lt;/a&gt;2.5.3 堆&lt;/h3&gt;&lt;p&gt;堆（heap) 用来存放对象和数组实例，被所有线程共享。&lt;br&gt;堆在jvm启动时创建，实现时可以固定大小或者自由伸缩。&lt;br&gt;异常：&lt;br&gt;OutOfMemoryError: 计算要求过多的内存&lt;/p&gt;
&lt;h3 id=&quot;2-5-4-方法区&quot;&gt;&lt;a href=&quot;#2-5-4-方法区&quot; class=&quot;headerlink&quot; title=&quot;2.5.4 方法区&quot;&gt;&lt;/a&gt;2.5.4 方法区&lt;/h3&gt;&lt;p&gt;方法区，按类存放常量池，属性和方法信息，包括方法的指令列表。&lt;br&gt;方法区在逻辑上属于堆内存。&lt;br&gt;方法区不够用，抛出 OutOfMemoryError。&lt;/p&gt;
&lt;h3 id=&quot;2-5-5-常量池&quot;&gt;&lt;a href=&quot;#2-5-5-常量池&quot; class=&quot;headerlink&quot; title=&quot;2.5.5 常量池&quot;&gt;&lt;/a&gt;2.5.5 常量池&lt;/h3&gt;&lt;p&gt;类似其他语言的符号表，包含类或接口的常量定义，或需要解析的方法或属性表。&lt;br&gt;常量池是方法区的一部分。&lt;/p&gt;
&lt;h3 id=&quot;2-5-6-本地方法栈&quot;&gt;&lt;a href=&quot;#2-5-6-本地方法栈&quot; class=&quot;headerlink&quot; title=&quot;2.5.6 本地方法栈&quot;&gt;&lt;/a&gt;2.5.6 本地方法栈&lt;/h3&gt;&lt;p&gt;在创建线程时，可以分配固定的本地栈，或者支持动态伸缩。&lt;br&gt;同样可能抛出 StackOverflowError 和 OutOfMemoryError&lt;/p&gt;
&lt;h3 id=&quot;2-6-Frame-方法帧&quot;&gt;&lt;a href=&quot;#2-6-Frame-方法帧&quot; class=&quot;headerlink&quot; title=&quot;2.6 Frame 方法帧&quot;&gt;&lt;/a&gt;2.6 Frame 方法帧&lt;/h3&gt;&lt;p&gt;当线程掉用一个方法的时候，就会在栈上开辟一个方法帧，这个帧的大小是编译时确定的。&lt;br&gt;每个线程都有一个当前方法和当前帧。方法开始时压栈，方法结束时退栈。&lt;br&gt;帧的作用： 保存本地变量（引用或者基本类型，不是对象本身），保存计算的中间结果，动态链接（比如方法使用到了新的类），返回值处理，异常处理。&lt;/p&gt;
&lt;h3 id=&quot;2-6-1-本地变量&quot;&gt;&lt;a href=&quot;#2-6-1-本地变量&quot; class=&quot;headerlink&quot; title=&quot;2.6.1 本地变量&quot;&gt;&lt;/a&gt;2.6.1 本地变量&lt;/h3&gt;&lt;p&gt;每个帧包含一个本地变量的数组，数组大小编译时确定。&lt;br&gt;单个变量可以保存： boolean, byte, char, short, int, float, reference等类型&lt;br&gt;两个变量用于保存： long, double 类型&lt;/p&gt;
&lt;p&gt;变量通过索引取值。从0到size -1。&lt;br&gt;long和double占用n和n+1两个连续的数组位置，通过较小的那个索引n读取，写入可以n和n+1都行，&lt;/p&gt;
&lt;p&gt;jvm使用本地变量来传递方法参数，从数组第0个位置开始存放。特别的，成员方法（而不是类方法）的第0个参数，永远都是this（当前对象的引用），其他参数从位置1开始存放。&lt;/p&gt;
&lt;h3 id=&quot;2-6-2-操作数栈&quot;&gt;&lt;a href=&quot;#2-6-2-操作数栈&quot; class=&quot;headerlink&quot; title=&quot;2.6.2 操作数栈&quot;&gt;&lt;/a&gt;2.6.2 操作数栈&lt;/h3&gt;&lt;p&gt;每个帧，都包含一个LIFO的操作数栈，栈的最大深度编译时决定。&lt;br&gt;帧创建的时候，操作数栈是空的，有些jvm指令负责将本地变量／常量或成员装载到栈上，如iload等。&lt;br&gt;其他jvm指令，将操作数取出执行计算，并将结果压栈。&lt;br&gt;特别大，方法的参数传递和返回值也是通过操作数栈进行的。&lt;/p&gt;
&lt;p&gt;long,double，或其他的类型，都是一次压栈和退栈操作。long和double在计算栈深度时，算2；其他算1深度。&lt;/p&gt;
&lt;p&gt;.class文件内容校验规则之一就是，操作数栈上的类型和接下来的操作指令要匹配上。&lt;/p&gt;
&lt;h3 id=&quot;2-6-3-动态链接&quot;&gt;&lt;a href=&quot;#2-6-3-动态链接&quot; class=&quot;headerlink&quot; title=&quot;2.6.3 动态链接&quot;&gt;&lt;/a&gt;2.6.3 动态链接&lt;/h3&gt;&lt;p&gt;jvm多态实现细节：&lt;br&gt;每个方法帧，都包含一个指向当前对象类型的常量池引用。&lt;br&gt;动态链接将.class内的符号表，转化为实际的方法地址。&lt;/p&gt;
&lt;p&gt;? 观察一下，java的多态是如何实现的。&lt;/p&gt;
&lt;h3 id=&quot;2-6-4-方法正常结束&quot;&gt;&lt;a href=&quot;#2-6-4-方法正常结束&quot; class=&quot;headerlink&quot; title=&quot;2.6.4 方法正常结束&quot;&gt;&lt;/a&gt;2.6.4 方法正常结束&lt;/h3&gt;&lt;p&gt;方法正常结束，指的是没有任何jvm内部异常，或者显示的throw异常。&lt;br&gt;方法帧可用于恢复调用者的状态，包括其本地变量和操作数表，而且pc要+1用于跳到下一个指令。&lt;/p&gt;
&lt;h3 id=&quot;2-6-5-方法异常结束&quot;&gt;&lt;a href=&quot;#2-6-5-方法异常结束&quot; class=&quot;headerlink&quot; title=&quot;2.6.5 方法异常结束&quot;&gt;&lt;/a&gt;2.6.5 方法异常结束&lt;/h3&gt;&lt;p&gt;异常结束指的是，方法抛出异常，且方法内没有捕获。&lt;br&gt;异常结束时，不再返回结果给调用者。&lt;/p&gt;
&lt;h3 id=&quot;2-7-对象的表示&quot;&gt;&lt;a href=&quot;#2-7-对象的表示&quot; class=&quot;headerlink&quot; title=&quot;2.7 对象的表示&quot;&gt;&lt;/a&gt;2.7 对象的表示&lt;/h3&gt;&lt;p&gt;jvm规范不规定对象在堆上怎么表示。&lt;/p&gt;
&lt;h3 id=&quot;2-8-浮点计算&quot;&gt;&lt;a href=&quot;#2-8-浮点计算&quot; class=&quot;headerlink&quot; title=&quot;2.8 浮点计算&quot;&gt;&lt;/a&gt;2.8 浮点计算&lt;/h3&gt;&lt;p&gt;jvm收录了相关ieee 754 标准的子集。&lt;/p&gt;
&lt;h3 id=&quot;2-9-特殊方法&quot;&gt;&lt;a href=&quot;#2-9-特殊方法&quot; class=&quot;headerlink&quot; title=&quot;2.9 特殊方法&quot;&gt;&lt;/a&gt;2.9 特殊方法&lt;/h3&gt;&lt;p&gt;&lt;init&gt; 实例构造函数，由指令 invokespecial调用&lt;/init&gt;&lt;/p&gt;
&lt;p&gt;&lt;cinit&gt; 类构造函数，由jvm在类或接口初始化时隐式调用。&lt;/cinit&gt;&lt;/p&gt;
&lt;p&gt;java.lang.invoke.MethodHandle中的invoke和invokeExact方法， 被称为是 动态签名的。&lt;br&gt;每个MethodHandle直接引用底层方法／构造函数等，支持参数等自动转换（所以叫动态签名）。&lt;/p&gt;
&lt;h3 id=&quot;2-10-异常&quot;&gt;&lt;a href=&quot;#2-10-异常&quot; class=&quot;headerlink&quot; title=&quot;2.10 异常&quot;&gt;&lt;/a&gt;2.10 异常&lt;/h3&gt;&lt;p&gt;异常分为：&lt;br&gt;同步异常： 如athrow指令，或者jvm发现了异常执行代码（如数组越界，OOM等）&lt;br&gt;异步异常： 调用Thread或ThreadGroup的stop方法， jvm内部异常&lt;/p&gt;
&lt;p&gt;异常抛出后，所有后续代码都不应该执行， 所有之前执行的代码都有效。 （类似一种 happens-before的关系，但这是单个线程，需要满足的是 as-if-serial ）&lt;/p&gt;
&lt;p&gt;.class文件中包含每个方法的异常处理表。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h3&gt;&lt;h3 id=&quot;1-1-java简史&quot;&gt;&lt;a href=&quot;#1-1-java简史&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="jvm" scheme="http://foojolt.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>scrapy</title>
    <link href="http://foojolt.github.io/2016/03/30/scrapy/"/>
    <id>http://foojolt.github.io/2016/03/30/scrapy/</id>
    <published>2016-03-30T03:07:14.000Z</published>
    <updated>2016-04-14T02:28:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;scrapy&quot;&gt;&lt;a href=&quot;#scrapy&quot; class=&quot;headerlink&quot; title=&quot;scrapy&quot;&gt;&lt;/a&gt;scrapy&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;big python project management
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;taobao spider:&lt;br&gt;&lt;a href=&quot;http://www.slideshare.net/cjhacker/spider-12966847&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.slideshare.net/cjhacker/spider-12966847&lt;/a&gt;&lt;br&gt;webkit server  -&amp;gt; scrapy -&amp;gt; scheduler( fifo, priority queue )&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bjhee.com/scrapy.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.bjhee.com/scrapy.html&lt;/a&gt;&lt;br&gt;extend scrapy.Item -&amp;gt; this is the result&lt;br&gt;extend CrawlSpider -&amp;gt; parse_item()  generate item from http response, support xpath&lt;/p&gt;
&lt;h3 id=&quot;usage&quot;&gt;&lt;a href=&quot;#usage&quot; class=&quot;headerlink&quot; title=&quot;usage&quot;&gt;&lt;/a&gt;usage&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;may save as json:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;scrapy crawl my_crawler -o my_crawler.json -t json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;output utf8, not unicode escape
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;item[‘title’] = title.encode(“utf8”)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scrapy shell
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fetch( url )&lt;br&gt;response.body&lt;br&gt;from scrapy import Selector&lt;br&gt;sel = Selector(text=’’)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;ascii&amp;apos; codec can&amp;apos;t decode byte 0xe5 in position 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;default_encoding = ‘utf-8’&lt;br&gt;if sys.getdefaultencoding() != default_encoding:&lt;br&gt;    reload(sys)&lt;br&gt;    sys.setdefaultencoding(default_encoding)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SearchSpider(CrawlSpider):
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;override def parse(self, response): to parse the start url’s content&lt;br&gt;use rules = [ Rule( LinkExtractor(), follow=False, callback=’parse’ ) ]&lt;br&gt;    to parse link by callback=xxx&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;scrapy&quot;&gt;&lt;a href=&quot;#scrapy&quot; class=&quot;headerlink&quot; title=&quot;scrapy&quot;&gt;&lt;/a&gt;scrapy&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;big python project management
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    </summary>
    
    
      <category term="scrapy" scheme="http://foojolt.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>deep learning essentials</title>
    <link href="http://foojolt.github.io/2016/03/28/deep-learning/"/>
    <id>http://foojolt.github.io/2016/03/28/deep-learning/</id>
    <published>2016-03-28T03:07:14.000Z</published>
    <updated>2016-04-14T02:33:21.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;deep-learning&quot;&gt;&lt;a href=&quot;#deep-learning&quot; class=&quot;headerlink&quot; title=&quot;deep-learning&quot;&gt;&lt;/a&gt;deep-learning&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://deeplearning.net/tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;deeplearning-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Very Brief Introduction to Machine Learning for AI
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://greenteapress.com/wp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;free books&lt;/a&gt;&lt;br&gt;think stat, think python&lt;/p&gt;
&lt;h3 id=&quot;milestone&quot;&gt;&lt;a href=&quot;#milestone&quot; class=&quot;headerlink&quot; title=&quot;milestone&quot;&gt;&lt;/a&gt;milestone&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Unsupervised Feature Learning and Deep Learning.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://ufldl.stanford.edu/wiki/index.php/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ufldl.stanford.edu/wiki/index.php/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ty4z2008/Qix/blob/master/dl.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ty4z2008/Qix/blob/master/dl.md&lt;/a&gt;&lt;br&gt;neuron&lt;br&gt;autoencoder: using theano to implement it&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Theano

五子棋

五子棋 powered by deeplearning

deeplearning for NLP

optinal
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ty4z2008/Qix/blob/master/dl.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ty4z2008/Qix/blob/master/dl.md&lt;/a&gt;   &lt;/p&gt;
&lt;h3 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h3&gt;&lt;p&gt;narray, multidimensional array object&lt;br&gt;sudo apt-get build-dep python-scipy&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import numpy
import theano.tensor as T
x = T.dscalar(&amp;apos;x&amp;apos;)
y = T.dscalar(&amp;apos;y&amp;apos;)
z = x + y
numpy.allclose(z.eval({x : 16.3, y : 12.1}), 28.4)

import theano
a = theano.tensor.vector() # declare variable
out = a + a ** 10               # build symbolic expression
f = theano.function([a], out)   # compile function
print(f([0, 1, 2]))

from theano import shared
state = shared(0)
inc = T.iscalar(&amp;apos;inc&amp;apos;)
accumulator = function([inc], state, updates=[(state, state+inc)])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;from theano.tensor.shared_randomstreams import RandomStreams&lt;br&gt;from theano import function&lt;br&gt;srng = RandomStreams(seed=234)&lt;br&gt;rv_u = srng.uniform((2,2))&lt;br&gt;rv_n = srng.normal((2,2))&lt;br&gt;f = function([], rv_u)&lt;br&gt;g = function([], rv_n, no_default_updates=True)    #Not updating rv_n.rng&lt;br&gt;nearly_zeros = function([], rv_u + rv_u - 2 * rv_u)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;deep-learning&quot;&gt;&lt;a href=&quot;#deep-learning&quot; class=&quot;headerlink&quot; title=&quot;deep-learning&quot;&gt;&lt;/a&gt;deep-learning&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://deeplearni
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://foojolt.github.io/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>python machine learning</title>
    <link href="http://foojolt.github.io/2016/03/28/python-ml/"/>
    <id>http://foojolt.github.io/2016/03/28/python-ml/</id>
    <published>2016-03-28T03:07:14.000Z</published>
    <updated>2016-03-29T13:35:26.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="python" scheme="http://foojolt.github.io/tags/python/"/>
    
      <category term="machine-learning" scheme="http://foojolt.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Ruby技巧</title>
    <link href="http://foojolt.github.io/2016/03/23/ruby/"/>
    <id>http://foojolt.github.io/2016/03/23/ruby/</id>
    <published>2016-03-23T03:07:14.000Z</published>
    <updated>2016-04-14T02:28:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;install&quot;&gt;&lt;a href=&quot;#install&quot; class=&quot;headerlink&quot; title=&quot;install&quot;&gt;&lt;/a&gt;install&lt;/h3&gt;&lt;p&gt;sudo gem sources -c&lt;br&gt;sudo gem sources -a &lt;a href=&quot;http://rubygems.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://rubygems.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;see Gemfile:&lt;br&gt;source xxx&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;install&quot;&gt;&lt;a href=&quot;#install&quot; class=&quot;headerlink&quot; title=&quot;install&quot;&gt;&lt;/a&gt;install&lt;/h3&gt;&lt;p&gt;sudo gem sources -c&lt;br&gt;sudo gem sources -a &lt;a href
    
    </summary>
    
    
      <category term="ruby" scheme="http://foojolt.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://foojolt.github.io/2016/03/21/os-tcpip/"/>
    <id>http://foojolt.github.io/2016/03/21/os-tcpip/</id>
    <published>2016-03-21T08:30:48.000Z</published>
    <updated>2016-03-21T08:35:06.000Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;title:  OS TCP/IP&lt;br&gt;date: 2016-03-17 10:07:14&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS&lt;/li&gt;
&lt;li&gt;TCPIP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;数据的名称：&lt;br&gt;TCP: segment 段&lt;br&gt;IP: datagram 数据包&lt;br&gt;数据链路层: Frame 数据帧&lt;br&gt;物理层： 帧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:  OS TCP/IP&lt;br&gt;date: 2016-03-17 10:07:14&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS&lt;/li&gt;
&lt;li&gt;TCPIP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;数据的名称：&lt;br&gt;TCP: segm
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://foojolt.github.io/2016/03/21/mysql/"/>
    <id>http://foojolt.github.io/2016/03/21/mysql/</id>
    <published>2016-03-21T06:33:53.000Z</published>
    <updated>2016-03-21T07:45:18.000Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;title: Mysql Essentials&lt;br&gt;date: 2016-03-17 10:07:14&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Mysql-事务&quot;&gt;&lt;a href=&quot;#Mysql-事务&quot; class=&quot;headerlink&quot; title=&quot;Mysql 事务&quot;&gt;&lt;/a&gt;Mysql 事务&lt;/h3&gt;&lt;p&gt;两阶段锁：&lt;br&gt;加锁阶段： 读取共享锁（S锁）， 写入排他锁（X锁）&lt;br&gt;释放阶段：&lt;/p&gt;
&lt;p&gt;隔离级别：&lt;br&gt;未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据&lt;br&gt;提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)&lt;br&gt;可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读&lt;br&gt;串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/p&gt;
&lt;p&gt;不可重复读： 针对update和delete&lt;br&gt;幻读：针对insert操作，可以读到之前不存在的记录&lt;/p&gt;
&lt;p&gt;mysql锁的类型： 行锁， 表锁&lt;/p&gt;
&lt;p&gt;SET session transaction isolation level read committed;&lt;br&gt;SET SESSION binlog_format = ‘ROW’;（或者是MIXED）&lt;/p&gt;
&lt;p&gt;行锁：&lt;br&gt;update where id=xxx 行加锁&lt;br&gt;update where non_id = xxx 表锁 （mysql可能违反两阶段原则，在发现满足条件时，释放有关行；但由于没有索引，效率也不高）&lt;/p&gt;
&lt;p&gt;mysql在 read committed 级别， 读操作不会加锁；&lt;/p&gt;
&lt;p&gt;解决不可重复读／脏读读问题： 乐观锁， 多版本并发控制 mvcc， multi-version concurrent control&lt;/p&gt;
&lt;p&gt;mysql mvcc: 在每一行的后面， 增加两个隐藏的值： 创建事务id （insert/update） 和过期事务id(update/delete)&lt;/p&gt;
&lt;p&gt;SELECT时，读取创建版本号&amp;lt;=当前事务版本号，删除版本号为空或&amp;gt;当前事务版本号。&lt;br&gt;INSERT时，保存当前事务版本号为行的创建版本号&lt;br&gt;DELETE时，保存当前事务版本号为行的删除版本号&lt;br&gt;UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行&lt;/p&gt;
&lt;p&gt;update会新建一条记录&lt;/p&gt;
&lt;p&gt;快照读和加锁读&lt;br&gt;mysql引入快照读，提升性能&lt;/p&gt;
&lt;p&gt;next-key 锁： 行锁和gap锁的结合体&lt;br&gt;gap锁防止区间插入，从而防止了幻读的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: Mysql Essentials&lt;br&gt;date: 2016-03-17 10:07:14&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Mysql-事务&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hadoop 常用命令</title>
    <link href="http://foojolt.github.io/2016/03/18/hadoop-essentials/"/>
    <id>http://foojolt.github.io/2016/03/18/hadoop-essentials/</id>
    <published>2016-03-18T09:12:14.000Z</published>
    <updated>2016-04-12T12:22:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Metrics-Counters&quot;&gt;&lt;a href=&quot;#Metrics-Counters&quot; class=&quot;headerlink&quot; title=&quot;Metrics Counters&quot;&gt;&lt;/a&gt;Metrics Counters&lt;/h3&gt;&lt;p&gt;metrics 是关于系统和服务的，一般管理员关注；和 ganglia 等监控系统结合&lt;br&gt;counters，比如 mapreduce counters，是用户关注的，跟某次任务运行有关&lt;/p&gt;
&lt;h3 id=&quot;Counters&quot;&gt;&lt;a href=&quot;#Counters&quot; class=&quot;headerlink&quot; title=&quot;Counters&quot;&gt;&lt;/a&gt;Counters&lt;/h3&gt;&lt;p&gt;4 类： filesystem, job, framework, custom&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Metrics-Counters&quot;&gt;&lt;a href=&quot;#Metrics-Counters&quot; class=&quot;headerlink&quot; title=&quot;Metrics Counters&quot;&gt;&lt;/a&gt;Metrics Counters&lt;/h3&gt;&lt;p&gt;metrics 是关于系统和
    
    </summary>
    
    
      <category term="hadoop" scheme="http://foojolt.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Redis 及缓存</title>
    <link href="http://foojolt.github.io/2016/03/17/redis/"/>
    <id>http://foojolt.github.io/2016/03/17/redis/</id>
    <published>2016-03-17T02:07:14.000Z</published>
    <updated>2016-03-21T11:55:43.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Redis其他&quot;&gt;&lt;a href=&quot;#Redis其他&quot; class=&quot;headerlink&quot; title=&quot;Redis其他&quot;&gt;&lt;/a&gt;Redis其他&lt;/h3&gt;&lt;p&gt;###LRU&lt;/p&gt;
&lt;p&gt;maxmemory 2G&lt;br&gt;maxmemory-policy allkeys-lru&lt;br&gt;maxmemory-samples 10&lt;/p&gt;
&lt;p&gt;redis的行为是在每次add key之后，检查是否超过 max memory, 超过则启动一个 sample 算法，去除更老的key.&lt;/p&gt;
&lt;h3 id=&quot;缓存系统&quot;&gt;&lt;a href=&quot;#缓存系统&quot; class=&quot;headerlink&quot; title=&quot;缓存系统&quot;&gt;&lt;/a&gt;缓存系统&lt;/h3&gt;&lt;p&gt;redis特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;binlog， 故障恢复&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;li&gt;内存放不下，可以LRU写到文件中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Redis单线程&quot;&gt;&lt;a href=&quot;#Redis单线程&quot; class=&quot;headerlink&quot; title=&quot;Redis单线程&quot;&gt;&lt;/a&gt;Redis单线程&lt;/h3&gt;&lt;p&gt;Redis is single-threaded with epoll/kqueue and scales indefinitely in terms of I/O concurrency&lt;/p&gt;
&lt;p&gt;CPU 不是瓶颈， IO和内存才是&lt;/p&gt;
&lt;h3 id=&quot;Partition&quot;&gt;&lt;a href=&quot;#Partition&quot; class=&quot;headerlink&quot; title=&quot;Partition&quot;&gt;&lt;/a&gt;Partition&lt;/h3&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;批量key操作不可行&lt;/li&gt;
&lt;li&gt;批量key事务不可行&lt;/li&gt;
&lt;li&gt;基于key而不是value来做的，value很大也不能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分片方式：&lt;br&gt;client-side： 客户端手工配置&lt;br&gt;proxy： 代理分片&lt;br&gt;clustering： 没有中心点，类似cassendra， 每个节点都纪录其他接点的信息；出了问题不好定位；&lt;/p&gt;
&lt;p&gt;twemproxy: &lt;/p&gt;
&lt;p&gt;codis: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;codis group概念（ 包含至少一个master/slave)&lt;/li&gt;
&lt;li&gt;pre-sharding: 1024个分片，分片信息保存在zookeeper中&lt;br&gt;redis-client -&amp;gt; codis proxy…-&amp;gt; [ codis-grp1 (redis-master, redis-slave1, redis-slave2,…) , codis-grp2,… ]&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Redis-Cluster&quot;&gt;&lt;a href=&quot;#Redis-Cluster&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster&quot;&gt;&lt;/a&gt;Redis Cluster&lt;/h3&gt;&lt;p&gt;分为 16384 个槽，每个shard领取一部分；  16 * 1024 = 16384&lt;br&gt;用bitmap存储 node 和 shard的对应信息 （2K的bitmap）&lt;/p&gt;
&lt;h3 id=&quot;Redis-Sentinel&quot;&gt;&lt;a href=&quot;#Redis-Sentinel&quot; class=&quot;headerlink&quot; title=&quot;Redis-Sentinel&quot;&gt;&lt;/a&gt;Redis-Sentinel&lt;/h3&gt;&lt;p&gt;redis官方HA机制： 实现了一个类似 zookeeper 的主备选举机制&lt;br&gt;数据要写到master，读可以从slave读； 延时 ＋ 分裂时的数据丢失&lt;/p&gt;
&lt;p&gt;Sentinel 和 redis 节点分开部署，至少3个&lt;/p&gt;
&lt;p&gt;asynchronous replication 异步复制&lt;/p&gt;
&lt;p&gt;Sentinel or Clustering:&lt;/p&gt;
&lt;p&gt;看情况，如果要求HA（即里面的数据很重要，在一段时间内不能丢失），用sentinel&lt;br&gt;所有节点存储的是相同的key-value&lt;/p&gt;
&lt;p&gt;如果只是做缓存，故障之后可以重建； 用 partition 的方案。&lt;/p&gt;
&lt;h3 id=&quot;一致性哈希与缓存&quot;&gt;&lt;a href=&quot;#一致性哈希与缓存&quot; class=&quot;headerlink&quot; title=&quot;一致性哈希与缓存&quot;&gt;&lt;/a&gt;一致性哈希与缓存&lt;/h3&gt;&lt;p&gt;分布式哈希的实现： 环状＋就近存储&lt;br&gt;根据 hash(node_ip) 分布缓存的node&lt;br&gt;hash(key)并顺时针找到最近的node&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平衡性： 均匀分布&lt;/li&gt;
&lt;li&gt;单调性： 缓存node增加和删除，只有部分key需要迁移&lt;/li&gt;
&lt;li&gt;平衡性： 虚拟node，hash(node_ip#1),hash(node_ip#2) …&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/cywosp/article/details/23397179&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cywosp/article/details/23397179&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis其他&quot;&gt;&lt;a href=&quot;#Redis其他&quot; class=&quot;headerlink&quot; title=&quot;Redis其他&quot;&gt;&lt;/a&gt;Redis其他&lt;/h3&gt;&lt;p&gt;###LRU&lt;/p&gt;
&lt;p&gt;maxmemory 2G&lt;br&gt;maxmemory-policy all
    
    </summary>
    
    
      <category term="性能" scheme="http://foojolt.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="redis" scheme="http://foojolt.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Scala</title>
    <link href="http://foojolt.github.io/2016/03/17/scala/"/>
    <id>http://foojolt.github.io/2016/03/17/scala/</id>
    <published>2016-03-17T02:07:14.000Z</published>
    <updated>2016-03-18T03:59:57.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="scala" scheme="http://foojolt.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>everstring</title>
    <link href="http://foojolt.github.io/2016/03/14/everstring/"/>
    <id>http://foojolt.github.io/2016/03/14/everstring/</id>
    <published>2016-03-14T03:07:14.000Z</published>
    <updated>2016-03-25T23:36:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.weixinyidu.com/n_3209047&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; everstring 产品技术解读 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据来源：&lt;br&gt;internet, pixel(网站行为), traffic&lt;br&gt;commercial&lt;br&gt;==&amp;gt; 11M, 10K&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.weixinyidu.com/n_3209047&quot; target=&quot;_blank&quot; 
    
    </summary>
    
    
      <category term="everstring" scheme="http://foojolt.github.io/tags/everstring/"/>
    
  </entry>
  
  <entry>
    <title>Spark essentials</title>
    <link href="http://foojolt.github.io/2016/03/14/spark/"/>
    <id>http://foojolt.github.io/2016/03/14/spark/</id>
    <published>2016-03-14T03:07:14.000Z</published>
    <updated>2016-03-18T09:45:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;RDD组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分区列表&lt;/li&gt;
&lt;li&gt;分区计算函数&lt;/li&gt;
&lt;li&gt;父RDD依赖列表&lt;/li&gt;
&lt;li&gt;可选： key,value RDD的Partition函数&lt;/li&gt;
&lt;li&gt;可选： hdfs rdd的优选位置（preferred location）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;./bin/spark-shell  –master local[3]&lt;br&gt;val r = sc.parallelize( Array( (1,2), (2,3), (3,4), (3,5)  ), 4 )&lt;br&gt;r.toDebugString&lt;/p&gt;
&lt;h3 id=&quot;RDD-API&quot;&gt;&lt;a href=&quot;#RDD-API&quot; class=&quot;headerlink&quot; title=&quot;RDD API&quot;&gt;&lt;/a&gt;RDD API&lt;/h3&gt;&lt;p&gt;计算split：&lt;br&gt;abstract def&lt;br&gt;compute(split: Partition, context: TaskContext): Iterator[T]&lt;/p&gt;
&lt;p&gt;Union组合RDD：&lt;br&gt;++(other: RDD[T]): RDD[T]&lt;/p&gt;
&lt;p&gt;值聚合：&lt;br&gt;def&lt;br&gt;aggregate&lt;a href=&quot;zeroValue: U&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;U&lt;/a&gt;(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): U&lt;br&gt;r.aggregate( “” )( ( t, a ) =&amp;gt; t + a._1.toString, ( x, y ) =&amp;gt; x + y  )&lt;/p&gt;
&lt;p&gt;groupByKey有内存警告&lt;/p&gt;
&lt;h3 id=&quot;Job运行原理&quot;&gt;&lt;a href=&quot;#Job运行原理&quot; class=&quot;headerlink&quot; title=&quot;Job运行原理&quot;&gt;&lt;/a&gt;Job运行原理&lt;/h3&gt;&lt;p&gt;Transformation 只是构造DAG，不做其他事情。通过sc.runJob 物化&lt;br&gt;执行优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;transformation 可以 pipeline&lt;/li&gt;
&lt;li&gt;graph可能由于cache/checkpoint被截断，之前的不用计算了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Job is list of stages&lt;br&gt;    stage is list of tasks ( stage内的task彼此无依赖 )&lt;/p&gt;
&lt;p&gt;shuffle happens between stages&lt;/p&gt;
&lt;p&gt;Job优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少 shuffle: 比如用reduceByKey而不是 groupByKey&lt;/li&gt;
&lt;li&gt;早点调用filter&lt;/li&gt;
&lt;li&gt;并发度控制： 太多调度不过来（同时运行的task有限）；太少就类似单机了&lt;/li&gt;
&lt;li&gt;选择序列化器： 比如 kryo, 用在 cache 和 shuffle&lt;/li&gt;
&lt;li&gt;选择cache级别： memory_only，用原生的jvm序列化；memory_only_ser 可以减少内存使用； memory_and_disk 容错性增强，减少重复计算&lt;/li&gt;
&lt;li&gt;采用lzf压缩，提高性能&lt;/li&gt;
&lt;li&gt;启用 speculative 执行预防stragglers: 有的任务运行慢，可以开启探测，重新调度；可以配置探测间隔；乘数（大于乘数＊中位数的任务，将重新跑）；完成的任务数比例，确保在大部分任务跑完时才探测&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;rdd.toDebugString 查看DAG&lt;/p&gt;
&lt;h3 id=&quot;压缩&quot;&gt;&lt;a href=&quot;#压缩&quot; class=&quot;headerlink&quot; title=&quot;压缩&quot;&gt;&lt;/a&gt;压缩&lt;/h3&gt;&lt;p&gt;压缩：用CPU换IO&lt;br&gt;mapreduce压缩可用在三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入文件&lt;/li&gt;
&lt;li&gt;map输出&lt;/li&gt;
&lt;li&gt;reduce输出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法：&lt;br&gt;lzo  支持分片，压缩速度快；但压缩比低(snapy/lzf 和 lzo 类似)&lt;br&gt;bzip2 支持分片，压缩比高；但压缩慢&lt;/p&gt;
&lt;h3 id=&quot;Shuffle&quot;&gt;&lt;a href=&quot;#Shuffle&quot; class=&quot;headerlink&quot; title=&quot;Shuffle&quot;&gt;&lt;/a&gt;Shuffle&lt;/h3&gt;&lt;p&gt;shuffle中间文件的问题：&lt;br&gt;个数是 t * R ： 每个 executor 最多 t个task同时运行(一般等于core_num)&lt;/p&gt;
&lt;p&gt;shuffle默认启用sort，之前的版本有hash版本的，因为spark认为sort带来额外开销。但hash需要放内存中；sort是外部排序&lt;/p&gt;
&lt;p&gt;默认采用netty传输数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Akka-RPC&quot;&gt;&lt;a href=&quot;#Akka-RPC&quot; class=&quot;headerlink&quot; title=&quot;Akka RPC&quot;&gt;&lt;/a&gt;Akka RPC&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;RDD组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分区列表&lt;/li&gt;
&lt;li&gt;分区计算函数&lt;/li&gt;
&lt;li&gt;父RDD依赖列表&lt;/li&gt;
&lt;li&gt;可选
    
    </summary>
    
    
      <category term="spark" scheme="http://foojolt.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Java有趣知识</title>
    <link href="http://foojolt.github.io/2016/03/14/java-essentials/"/>
    <id>http://foojolt.github.io/2016/03/14/java-essentials/</id>
    <published>2016-03-14T03:07:14.000Z</published>
    <updated>2016-03-22T05:58:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;内存映射&quot;&gt;&lt;a href=&quot;#内存映射&quot; class=&quot;headerlink&quot; title=&quot;内存映射&quot;&gt;&lt;/a&gt;内存映射&lt;/h3&gt;&lt;p&gt;MappedByteBuffer:&lt;/p&gt;
&lt;p&gt;从 FileChannel创建， 可以是 RandomAccessFile，支持读写； 模式可以是 只读／读写／私有， 私有的修改不会刷回文件中。&lt;/p&gt;
&lt;h3 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h3&gt;&lt;p&gt;linux io 模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blocking    non-blocking
-------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;synchronous  | old io       app多次请求，直到条件满足&lt;br&gt;asynchronous | select/epoll       AIO&lt;/p&gt;
&lt;p&gt;select 与 old io 的区别： old io是对IO调用阻塞； select 是对事件通知阻塞&lt;/p&gt;
&lt;p&gt;nodejs使用libeio，默认内部使用4个IO线程。&lt;/p&gt;
&lt;p&gt;select/poll，都是提供一堆fd和关心的事件给内核；然后循环阻塞探测到状态变化时，再逐个检查原来的fd，看看哪个有变化；&lt;br&gt;poll和select的区别：用了一个结构体；没有1024数量限制&lt;br&gt;epoll返回有变化的fd集合。而且不用每次拷贝fd到内核（后续调用使用 epollfd ）&lt;/p&gt;
&lt;p&gt;java: bio, nio, aio(jdk7)&lt;/p&gt;
&lt;p&gt;AIO: app侧提供buffer,回调函数callback； callback在内核栈上执行&lt;br&gt;API：&lt;br&gt;aio_read    请求异步读操作&lt;br&gt;aio_error   检查异步请求的状态&lt;br&gt;aio_return  获得完成的异步请求的返回状态&lt;br&gt;…&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-async/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-async/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;netty&quot;&gt;&lt;a href=&quot;#netty&quot; class=&quot;headerlink&quot; title=&quot;netty&quot;&gt;&lt;/a&gt;netty&lt;/h3&gt;&lt;p&gt;channel -&amp;gt; channel pipeline -&amp;gt; channelHandlers &lt;/p&gt;
&lt;p&gt;network read -&amp;gt; upstream handlers&lt;br&gt;io request -&amp;gt; downstream handlers -&amp;gt; sink&lt;/p&gt;
&lt;p&gt;netty 3的问题： 每次有IO消息，就产生event，增加GC时间&lt;br&gt;netty 4: 不在包装event，而是调用相应的接口处理方法； 开发自己的malloc，不用填充0；自己管理，减少gc&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://m.oschina.net/blog/178561&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://m.oschina.net/blog/178561&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;行为：&lt;br&gt;coreSize -&amp;gt; taskQueue -&amp;gt; maxSize&lt;br&gt;只要coreSize没有达到，就创建新的线程；&lt;br&gt;否则任务进队列: 判断offer是否返回true;&lt;br&gt;进队列失败，且 &amp;lt; maxSize，创建新的线程；&lt;br&gt;否则，调用 handler处理。&lt;/p&gt;
&lt;p&gt;newFixedThreadPool: core==max, 无边界的 LinkedBlockingQueue，只要大于core，就无限制排队&lt;br&gt;newCachedThreadPool: SynchronousQueue，执行任务为0，立即入队列；否则失败，创建新的线程执行任务。&lt;br&gt;ArrayBlockingQueue: 考虑用这个，一旦队列满，就停止入队；降低系统负载；&lt;/p&gt;
&lt;h3 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a&gt;内存模型&lt;/h3&gt;&lt;p&gt;内存模型确定了一些规则：线程对内存的访问如何排序，以及如何确保内存对线程可见&lt;br&gt;包括： 重排序，内存可见性，happens-before&lt;/p&gt;
&lt;p&gt;重排序包括： 编译器重排序 CPU重排序 缓存导致的写入主内存重排序&lt;/p&gt;
&lt;p&gt;可见性： 内存屏障实现&lt;/p&gt;
&lt;p&gt;happens-before法则：&lt;br&gt;－ 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。&lt;br&gt;－ 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。&lt;br&gt;－ volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。&lt;br&gt;－ 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C&lt;br&gt;－ 对final语义的扩展保证一个对象的构建方法结束前，所有final成员变量都必须完成初始化（的前提是没有this引用溢出）。&lt;br&gt;－ 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。&lt;br&gt;－ 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。&lt;br&gt;－ 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。&lt;br&gt;－ 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。&lt;/p&gt;
&lt;p&gt;一个volatile happens-before原则的应用：&lt;br&gt;class VolatileExample {&lt;br&gt;    int x = 0;&lt;br&gt;    volatile boolean v = false;&lt;br&gt;    public void writer() {&lt;br&gt;        x = 42;&lt;br&gt;        v = true;&lt;br&gt;    }&lt;br&gt;    public void reader() {&lt;br&gt;        if (v == true) {&lt;br&gt;            //uses x - guaranteed to see 42.&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/p&gt;
&lt;h3 id=&quot;BlockingQueue&quot;&gt;&lt;a href=&quot;#BlockingQueue&quot; class=&quot;headerlink&quot; title=&quot;BlockingQueue&quot;&gt;&lt;/a&gt;BlockingQueue&lt;/h3&gt;&lt;p&gt;offer和poll提供超时参数&lt;/p&gt;
&lt;h3 id=&quot;CopyOnWriteArrayList&quot;&gt;&lt;a href=&quot;#CopyOnWriteArrayList&quot; class=&quot;headerlink&quot; title=&quot;CopyOnWriteArrayList&quot;&gt;&lt;/a&gt;CopyOnWriteArrayList&lt;/h3&gt;&lt;p&gt;每次修改，都创建一个新的底层Array: 读的线程，拿到的可能是失效的快照&lt;/p&gt;
&lt;h3 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h3&gt;&lt;p&gt;Map is list of Segment&lt;br&gt;    Segment is list of HashEntry&lt;/p&gt;
&lt;p&gt;用分离锁实现多个线程间的并发写操作&lt;br&gt;用 HashEntery 对象的不变性来降低读操作对加锁的需求&lt;br&gt;用 Volatile 变量协调读写线程间的内存可见性（value是volatile的，保证写入之后可以被其他线程看见；修改之后，改变volatile的modCount）&lt;/p&gt;
&lt;p&gt;HashEntry 是一个为无锁读优化的链表：&lt;br&gt;value 是volatile，表示如果读的时候正在改写能立即体现&lt;br&gt;next 是final，表示只能往前插入节点： 拿到一个hashEntry，它的链表元素是固定的（value除外）&lt;/p&gt;
&lt;p&gt; static final class HashEntry&lt;k,v&gt; {&lt;br&gt;        final K key;                       // 声明 key 为 final 型&lt;br&gt;        final int hash;                   // 声明 hash 值为 final 型&lt;br&gt;        volatile V value;                 // 声明 value 为 volatile 型&lt;br&gt;        final HashEntry&lt;k,v&gt; next;      // 声明 next 为 final 型 &lt;/k,v&gt;&lt;/k,v&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HashEntry(K key, int hash, HashEntry&amp;lt;K,V&amp;gt; next, V value) { 
    this.key = key; 
    this.hash = hash; 
    this.next = next; 
    this.value = value; 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内存映射&quot;&gt;&lt;a href=&quot;#内存映射&quot; class=&quot;headerlink&quot; title=&quot;内存映射&quot;&gt;&lt;/a&gt;内存映射&lt;/h3&gt;&lt;p&gt;MappedByteBuffer:&lt;/p&gt;
&lt;p&gt;从 FileChannel创建， 可以是 RandomAccessFile
    
    </summary>
    
    
      <category term="java" scheme="http://foojolt.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Jvm 性能分析</title>
    <link href="http://foojolt.github.io/2016/03/14/jvm/"/>
    <id>http://foojolt.github.io/2016/03/14/jvm/</id>
    <published>2016-03-14T03:07:14.000Z</published>
    <updated>2016-03-17T09:40:47.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;性能分析方法&quot;&gt;&lt;a href=&quot;#性能分析方法&quot; class=&quot;headerlink&quot; title=&quot;性能分析方法&quot;&gt;&lt;/a&gt;性能分析方法&lt;/h3&gt;&lt;p&gt;自顶（APP）向下 自底（CPU／内存）向上&lt;/p&gt;
&lt;h3 id=&quot;CPU相关&quot;&gt;&lt;a href=&quot;#CPU相关&quot; class=&quot;headerlink&quot; title=&quot;CPU相关&quot;&gt;&lt;/a&gt;CPU相关&lt;/h3&gt;&lt;p&gt;vmstat 主要观察调度队列度大小，cpu interrupt/context switch, cpu usage等相关数据&lt;/p&gt;
&lt;h3 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/java-se-16-synchronized&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infoq.com/cn/articles/java-se-16-synchronized&lt;/a&gt;&lt;br&gt;CAS compare and swap&lt;br&gt;同步的原理： monitor 对象&lt;br&gt;锁状态存储在对象头中&lt;/p&gt;
&lt;p&gt;锁的升级：&lt;br&gt;偏向锁，默认开启，因为发现大部分情况下，锁都是由同一个线程获得&lt;br&gt;自旋锁，不会阻塞，需要轮询；在多核CPU的情况下，可以避免让步上下文切换&lt;br&gt;重量级锁，线程阻塞&lt;/p&gt;
&lt;h3 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h3&gt;&lt;p&gt;compare and swap: 用在 atomic, incrementAndGet， 循环比较&lt;/p&gt;
&lt;p&gt;AtomicReference 可以用来实现无锁的Stack等。&lt;/p&gt;
&lt;p&gt;CAS循环探测的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在并发较高时，多数线程在探测，影响性能&lt;/li&gt;
&lt;li&gt;有时候compare返回true，可不能swap，可能状态已经变了（比如一个stack只保存head，实际上同一个head插入来两次）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和并行&quot;&gt;&lt;/a&gt;并发和并行&lt;/h3&gt;&lt;p&gt;Concurrency: A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism. 逻辑上&lt;/p&gt;
&lt;p&gt;Parallelism: A condition that arises when at least two threads are executing simultaneously.  物理上的&lt;/p&gt;
&lt;h3 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h3&gt;&lt;p&gt;bootstrap classloader&lt;br&gt;ext classloader&lt;br&gt;system classloader&lt;/p&gt;
&lt;p&gt;初始化加载器： loadClass() 会掉用findClass,比如URLClassLoader，如果没找到资源，直接跑出classNotFoundException&lt;/p&gt;
&lt;p&gt;定义类加载器: defineClass() 通过读取 byte[]，如果发现没有指定的类定义，则抛出NoClassDefFoundError&lt;/p&gt;
&lt;p&gt;线程上下文加载器：应对SPI的场景。&lt;/p&gt;
&lt;p&gt;Class.forName:简便方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;br&gt;return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&lt;br&gt;附： jdbc4以前，需要 Class.forName来加载指定的Driver，因为这样会初始化这个类：Driver就是这个时候，将自己注册到DriverManager的；jdbc4在DriverManager.getConnection getDrivers方法中，会去找 services/java.sql.Driver文件并加载所有的Driver，需要用到线程上下文类加载器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接：&lt;br&gt;验证 可能抛出VerifyError&lt;br&gt;准备 准备静态域并设为默认值&lt;br&gt;解析 处理符号表中有其他的类引用，可能导致其他类被加载&lt;/p&gt;
&lt;p&gt;初始化：&lt;br&gt;初始化静态域和执行静态代码&lt;/p&gt;
&lt;h3 id=&quot;jvm线程管理&quot;&gt;&lt;a href=&quot;#jvm线程管理&quot; class=&quot;headerlink&quot; title=&quot;jvm线程管理&quot;&gt;&lt;/a&gt;jvm线程管理&lt;/h3&gt;&lt;p&gt;线程模型： 和OS线程一一对应&lt;/p&gt;
&lt;p&gt;两种方式创建线程：&lt;br&gt;new Thread().start(): JavaThread(C++) -&amp;gt; OSThread&lt;br&gt;attach一个本地线程到jvm: 比如 CreateVM 时，是首先创建一个本地线程，做必要的初始化之后，再attach&lt;/p&gt;
&lt;p&gt;从JVM角度看Thread State:&lt;br&gt;new, in_java, in_vm, blocked( monitor_wait, condition_var_wait, object_wait )&lt;/p&gt;
&lt;p&gt;安全点：&lt;br&gt;比如GC的时候&lt;/p&gt;
&lt;h3 id=&quot;JVM-C-heap-manage&quot;&gt;&lt;a href=&quot;#JVM-C-heap-manage&quot; class=&quot;headerlink&quot; title=&quot;JVM C++ heap manage&quot;&gt;&lt;/a&gt;JVM C++ heap manage&lt;/h3&gt;&lt;p&gt;Arena ChunkPool 自定义的内存分配，而不是 malloc&lt;/p&gt;
&lt;p&gt;###JVM致命错误处理&lt;/p&gt;
&lt;p&gt;-XX:ErrorFile=&lt;br&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;br&gt;-XX:HeapDumpPath=&lt;pathname&gt;&lt;/pathname&gt;&lt;/p&gt;
&lt;h3 id=&quot;jvm参数&quot;&gt;&lt;a href=&quot;#jvm参数&quot; class=&quot;headerlink&quot; title=&quot;jvm参数&quot;&gt;&lt;/a&gt;jvm参数&lt;/h3&gt;&lt;p&gt;标准参数，扩展参数，不稳定的参数&lt;/p&gt;
&lt;p&gt;PERM | OLD | NEW[eden ss1 ss2]&lt;/p&gt;
&lt;p&gt;-Xloggc:filename&lt;br&gt;-Xms:初始堆大小&lt;br&gt;-Xmx:最大堆大小&lt;br&gt;-XX:NewSize=n:设置年轻代大小&lt;br&gt;-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4&lt;br&gt;-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5&lt;br&gt;-XX:MaxPermSize=n:设置持久代大小&lt;/p&gt;
&lt;h3 id=&quot;常见诊断工具&quot;&gt;&lt;a href=&quot;#常见诊断工具&quot; class=&quot;headerlink&quot; title=&quot;常见诊断工具&quot;&gt;&lt;/a&gt;常见诊断工具&lt;/h3&gt;&lt;p&gt; jinfo pid 获取jvm的启动参数&lt;br&gt; jmap －heap pid&lt;br&gt; jmap -dump:live,format=b,file=heap.bin pid live表示先gc&lt;br&gt; jstack pid&lt;/p&gt;
&lt;p&gt; jstat -gcutil pid time_range sample_count&lt;br&gt; S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   &lt;/p&gt;
&lt;h3 id=&quot;vmstat-命令解析&quot;&gt;&lt;a href=&quot;#vmstat-命令解析&quot; class=&quot;headerlink&quot; title=&quot;vmstat 命令解析&quot;&gt;&lt;/a&gt;vmstat 命令解析&lt;/h3&gt;&lt;h2 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU:&quot;&gt;&lt;/a&gt;CPU:&lt;/h2&gt;&lt;p&gt;r 调度队列的大小，参考cpu核数&lt;br&gt;b 阻塞的任务数&lt;/p&gt;
&lt;h2 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory: &quot;&gt;&lt;/a&gt;Memory: &lt;/h2&gt;&lt;p&gt;swapd 交换内存大小&lt;br&gt;free&lt;br&gt;buff&lt;br&gt;cache&lt;/p&gt;
&lt;h2 id=&quot;Swap&quot;&gt;&lt;a href=&quot;#Swap&quot; class=&quot;headerlink&quot; title=&quot;Swap:&quot;&gt;&lt;/a&gt;Swap:&lt;/h2&gt;&lt;p&gt;si&lt;br&gt;so&lt;/p&gt;
&lt;h2 id=&quot;io&quot;&gt;&lt;a href=&quot;#io&quot; class=&quot;headerlink&quot; title=&quot;io&quot;&gt;&lt;/a&gt;io&lt;/h2&gt;&lt;p&gt;bi&lt;br&gt;bo&lt;/p&gt;
&lt;h2 id=&quot;system&quot;&gt;&lt;a href=&quot;#system&quot; class=&quot;headerlink&quot; title=&quot;system &quot;&gt;&lt;/a&gt;system &lt;/h2&gt;&lt;p&gt;in (interrupt per second)&lt;br&gt;cs (context switch per second)&lt;/p&gt;
&lt;h2 id=&quot;cpu&quot;&gt;&lt;a href=&quot;#cpu&quot; class=&quot;headerlink&quot; title=&quot;cpu&quot;&gt;&lt;/a&gt;cpu&lt;/h2&gt;&lt;p&gt;us&lt;br&gt;sy&lt;br&gt;id&lt;br&gt;wa (time wait for io)&lt;br&gt;st (unknown)&lt;/p&gt;
&lt;p&gt;top -H -p pid 查看线程&lt;br&gt;pstree -p pid 查看线程&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;《Java性能调优》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;性能分析方法&quot;&gt;&lt;a href=&quot;#性能分析方法&quot; class=&quot;headerlink&quot; title=&quot;性能分析方法&quot;&gt;&lt;/a&gt;性能分析方法&lt;/h3&gt;&lt;p&gt;自顶（APP）向下 自底（CPU／内存）向上&lt;/p&gt;
&lt;h3 id=&quot;CPU相关&quot;&gt;&lt;a href=&quot;#CP
    
    </summary>
    
    
      <category term="jvm" scheme="http://foojolt.github.io/tags/jvm/"/>
    
      <category term="性能" scheme="http://foojolt.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>python相关</title>
    <link href="http://foojolt.github.io/2016/03/08/python-tips/"/>
    <id>http://foojolt.github.io/2016/03/08/python-tips/</id>
    <published>2016-03-08T03:13:14.000Z</published>
    <updated>2016-04-14T02:30:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=&quot;headerlink&quot; title=&quot;Python&quot;&gt;&lt;/a&gt;Python&lt;/h3&gt;&lt;p&gt;PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。&lt;/p&gt;
&lt;h3 id=&quot;system&quot;&gt;&lt;a href=&quot;#system&quot; class=&quot;headerlink&quot; title=&quot;system&quot;&gt;&lt;/a&gt;system&lt;/h3&gt;&lt;p&gt;sys.version&lt;br&gt;sys.platform&lt;br&gt;sys.argv&lt;br&gt;sys.maxint&lt;/p&gt;
&lt;p&gt;import re&lt;br&gt;dir(re) inspect module, object&lt;/p&gt;
&lt;h3 id=&quot;python-type-system&quot;&gt;&lt;a href=&quot;#python-type-system&quot; class=&quot;headerlink&quot; title=&quot;python type system&quot;&gt;&lt;/a&gt;python type system&lt;/h3&gt;&lt;p&gt;base type: object&lt;br&gt;primitive types: int, float, bool, long, complex&lt;br&gt;container type: tuple, string, unicode, list, set, fronzenset, dictionary&lt;br&gt;code type:&lt;br&gt;internal type:&lt;/p&gt;
&lt;p&gt;immutable: tuple, string, unicode, fronzenset&lt;/p&gt;
&lt;p&gt;isinstance(12, object)&lt;/p&gt;
&lt;h3 id=&quot;duck-type&quot;&gt;&lt;a href=&quot;#duck-type&quot; class=&quot;headerlink&quot; title=&quot;duck type&quot;&gt;&lt;/a&gt;duck type&lt;/h3&gt;&lt;p&gt;1 + 1 is syntax of 1.&lt;strong&gt;add&lt;/strong&gt;(1)&lt;br&gt;[1,2,3][0] =&amp;gt; [1,2,3].&lt;strong&gt;getitem&lt;/strong&gt;(0)&lt;/p&gt;
&lt;p&gt;isinstance(obj, type) vs duck type&lt;/p&gt;
&lt;h3 id=&quot;int-float&quot;&gt;&lt;a href=&quot;#int-float&quot; class=&quot;headerlink&quot; title=&quot;int float&quot;&gt;&lt;/a&gt;int float&lt;/h3&gt;&lt;p&gt;max value: sys.maxint, sys.float_info&lt;br&gt;32bit cpu: 2&lt;strong&gt;31 - 1, x64: 2&lt;/strong&gt;63 -1 &lt;/p&gt;
&lt;p&gt;long: not bounded&lt;/p&gt;
&lt;p&gt;literals 8 16 10 base: 0x123, 0123, 123&lt;/p&gt;
&lt;p&gt;right:&lt;br&gt;2&lt;strong&gt;2&lt;/strong&gt;3 = 2 &lt;strong&gt; ( 2 &lt;/strong&gt; 3 )&lt;/p&gt;
&lt;p&gt;10.1 // 2 == 5.0&lt;/p&gt;
&lt;h3 id=&quot;string-unicode&quot;&gt;&lt;a href=&quot;#string-unicode&quot; class=&quot;headerlink&quot; title=&quot;string unicode&quot;&gt;&lt;/a&gt;string unicode&lt;/h3&gt;&lt;p&gt;string is ascii characters&lt;/p&gt;
&lt;p&gt;unicode -&amp;gt; string:&lt;br&gt;u’或者’.encode(‘utf-8’)&lt;br&gt;=&amp;gt; ‘\xe6\x88\x96\xe8\x80\x85’&lt;br&gt;string -&amp;gt; unicode&lt;br&gt;unicode(‘\xe6\x88\x96\xe8\x80\x85’, ‘utf8’) =&amp;gt; u’或者’&lt;/p&gt;
&lt;p&gt;len(u’或者’) == 2&lt;/p&gt;
&lt;h3 id=&quot;list-map&quot;&gt;&lt;a href=&quot;#list-map&quot; class=&quot;headerlink&quot; title=&quot;list map&quot;&gt;&lt;/a&gt;list map&lt;/h3&gt;&lt;p&gt;letters = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]&lt;br&gt;letters[1]&lt;br&gt;if ‘a’ in letters:&lt;br&gt;    pass&lt;/p&gt;
&lt;p&gt;map = { “name”: “bob”, “age”:123 }&lt;br&gt;map[“name”]&lt;br&gt;if “name” in map:&lt;br&gt;    pass&lt;/p&gt;
&lt;p&gt;for k,v in map.iteritems():&lt;br&gt;    print k,v&lt;/p&gt;
&lt;h3 id=&quot;python-bytecode&quot;&gt;&lt;a href=&quot;#python-bytecode&quot; class=&quot;headerlink&quot; title=&quot;python bytecode&quot;&gt;&lt;/a&gt;python bytecode&lt;/h3&gt;&lt;p&gt;import dis&lt;/p&gt;
&lt;p&gt;def f():&lt;br&gt;    pass&lt;br&gt;dis.dis(f)&lt;/p&gt;
&lt;h3 id=&quot;python-debug&quot;&gt;&lt;a href=&quot;#python-debug&quot; class=&quot;headerlink&quot; title=&quot;python debug&quot;&gt;&lt;/a&gt;python debug&lt;/h3&gt;&lt;p&gt;break 或 b 设置断点  设置断点&lt;br&gt;continue 或 c    继续执行程序&lt;br&gt;list 或 l    查看当前行的代码段&lt;br&gt;step 或 s    进入函数&lt;br&gt;return 或 r  执行代码直到从当前函数返回&lt;br&gt;exit 或 q    中止并退出&lt;br&gt;next 或 n    执行下一行&lt;br&gt;pp  打印变量的值&lt;br&gt;help    帮助&lt;/p&gt;
&lt;h2 id=&quot;yield&quot;&gt;&lt;a href=&quot;#yield&quot; class=&quot;headerlink&quot; title=&quot;yield&quot;&gt;&lt;/a&gt;yield&lt;/h2&gt;&lt;p&gt;python bytecode:&lt;br&gt;YIELD_VALUE&lt;/p&gt;
&lt;p&gt;return generator, can send back information&lt;br&gt;can’t send non-None value to a just-started generator&lt;br&gt;send will trigger next value&lt;/p&gt;
&lt;h3 id=&quot;python-pip&quot;&gt;&lt;a href=&quot;#python-pip&quot; class=&quot;headerlink&quot; title=&quot;python pip&quot;&gt;&lt;/a&gt;python pip&lt;/h3&gt;&lt;p&gt;see package version:&lt;br&gt;pip show Flask&lt;br&gt;pip list&lt;/p&gt;
&lt;h3 id=&quot;Python-numpy&quot;&gt;&lt;a href=&quot;#Python-numpy&quot; class=&quot;headerlink&quot; title=&quot;Python numpy&quot;&gt;&lt;/a&gt;Python numpy&lt;/h3&gt;&lt;h3 id=&quot;Python-socket编程&quot;&gt;&lt;a href=&quot;#Python-socket编程&quot; class=&quot;headerlink&quot; title=&quot;Python socket编程&quot;&gt;&lt;/a&gt;Python socket编程&lt;/h3&gt;&lt;p&gt;int listen(int sockfd, int backlog)&lt;br&gt;默认时主动的，这个调用变成被动&lt;br&gt;backlog: OS 维护一个两个队列： 未连接的tcp队列（半连接），完成3次握手的tcp（准备好的）。准备好的tcp将交给进程（accept调用返回）； 为空则睡眠。&lt;/p&gt;
&lt;p&gt;backlog = 0， 可能引发 tcp flooding&lt;/p&gt;
&lt;p&gt;防止 tcp flooding:&lt;br&gt;使用F5，原理是完成3次握手的，才转发到服务器，有效阻挡半连接攻击&lt;br&gt;修改/etc/sysctl.conf, tcp_synack_retries = 0 即没收到客户端到ack，不重试；net.ipv4.tcp_max_syn_backlog = 200000 设置总到连接数&lt;/p&gt;
&lt;p&gt;socket状态：&lt;br&gt;开始连接：&lt;br&gt;listen&lt;br&gt;syn_sent&lt;br&gt;syn_rcvd&lt;br&gt;established&lt;br&gt;主动close:&lt;br&gt;fin_wait_1&lt;br&gt;fin_wait_2&lt;br&gt;closing&lt;br&gt;time_wait&lt;br&gt;被动：&lt;br&gt;close_wait&lt;br&gt;last_ack&lt;br&gt;关闭：&lt;br&gt;closed&lt;/p&gt;
&lt;h3 id=&quot;pyspark&quot;&gt;&lt;a href=&quot;#pyspark&quot; class=&quot;headerlink&quot; title=&quot;pyspark&quot;&gt;&lt;/a&gt;pyspark&lt;/h3&gt;&lt;p&gt;代码模板：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys 
from pyspark import SparkContext 
if __name__ == &amp;apos;__main__&amp;apos;:
    sc = SparkContext() #远程提交任务，采用默认配置 
    argv = sys.argv 
    src = argv[ len(argv)-2 ] 
    dst = argv[ len(argv)-1 ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/1.3.1/api/python/pyspark.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pyspark doc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;文档编码&quot;&gt;&lt;a href=&quot;#文档编码&quot; class=&quot;headerlink&quot; title=&quot;文档编码&quot;&gt;&lt;/a&gt;文档编码&lt;/h3&gt;&lt;p&gt;指定文档编码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: encoding -*-
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;try:
    line = raw_input()      #从stdin读入行
except EOFError:
    break                #在文件末尾退出循环
esle:
      # 其它处理代码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;抛出异常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;raise BaseException(&amp;quot;error&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h3&gt;&lt;p&gt;遍历：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m = dict()
for k,v in m.iteritems():
    print k,v
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;key，value相关操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map.get(&amp;quot;key1&amp;quot;) # 如果key、value对不存在，不会抛出异常
map[&amp;quot;key1&amp;quot;] # 可能抛出 KeyError 
key in map # 检查key,value对是否存在
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h3&gt;&lt;p&gt;执行一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -c ‘print 123&amp;apos;
python m1.py
python -m m1 比如当前文件夹下有一段代码 m1.py，这样将直接执行这个文件； 和 python m1.py效果一样。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;命令行参数传递&quot;&gt;&lt;a href=&quot;#命令行参数传递&quot; class=&quot;headerlink&quot; title=&quot;命令行参数传递&quot;&gt;&lt;/a&gt;命令行参数传递&lt;/h4&gt;&lt;p&gt;t.py:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys
print sys.argv 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行python t.py 123 124，打印：注意包含文件名本身&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ ’t.py’, ‘123’, ‘124&amp;apos; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -c “import sys; print sys.argv” 123
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打印：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[‘-c&amp;apos;, ‘123&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;基本运算&quot;&gt;&lt;a href=&quot;#基本运算&quot; class=&quot;headerlink&quot; title=&quot;基本运算&quot;&gt;&lt;/a&gt;基本运算&lt;/h3&gt;&lt;p&gt;向下取整的除法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4/5 == 0
4.0 // 5 == 0 强制向下取整除法，即使是浮点数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;求幂运算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2**3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;交互运算时，用_表示前一个结果&lt;/p&gt;
&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;p&gt;可以相加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;‘a’ + ‘b&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;‘a’*3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多行： 注意没有前导的换行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“””\
abc
def
“”&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用\转义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“this is \n a new line&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者取消\转义功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r“c:\a\b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多个相邻的字符串常量（变量不行），自动拼接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = ‘a’ ‘b&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a[0]
a[1]
a[-1] = a[len(a)-1]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a[0:1]
a[1:]
a[:1]
a[start:end_not_included]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果省略start，默认为0； 省略 end，默认为字符串长度&lt;br&gt;a[too_large]太大的索引，会报错&lt;br&gt;但是切片不会，根据情况，适配到 [start:end] 之间来。&lt;/p&gt;
&lt;p&gt;字符串不可变：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a[0] = ‘1’会失败
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;求长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;len(str)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class A:
  def __len__(self):
     return 102
  @classmethod
  def joke(cls):
      return “a class method %s” % cls
a = A()
print a.__len__()
print A.__len__(a)
print len(a)
print A.joke()
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=&quot;headerlink&quot; title=&quot;Python&quot;&gt;&lt;/a&gt;Python&lt;/h3&gt;&lt;p&gt;PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。&lt;
    
    </summary>
    
    
      <category term="python" scheme="http://foojolt.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vim tips</title>
    <link href="http://foojolt.github.io/2016/03/07/vim-tips/"/>
    <id>http://foojolt.github.io/2016/03/07/vim-tips/</id>
    <published>2016-03-07T08:07:14.000Z</published>
    <updated>2016-03-07T08:44:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;额外移动指令&quot;&gt;&lt;a href=&quot;#额外移动指令&quot; class=&quot;headerlink&quot; title=&quot;额外移动指令&quot;&gt;&lt;/a&gt;额外移动指令&lt;/h3&gt;&lt;p&gt;HML 大写的，分别移到上中下三个位置&lt;br&gt;zt zz zb 将光标所在行移到上中下上个位置&lt;/p&gt;
&lt;p&gt;end&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;额外移动指令&quot;&gt;&lt;a href=&quot;#额外移动指令&quot; class=&quot;headerlink&quot; title=&quot;额外移动指令&quot;&gt;&lt;/a&gt;额外移动指令&lt;/h3&gt;&lt;p&gt;HML 大写的，分别移到上中下三个位置&lt;br&gt;zt zz zb 将光标所在行移到上中下上个位置&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="vim" scheme="http://foojolt.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Solr基础</title>
    <link href="http://foojolt.github.io/2016/03/07/solr-basics/"/>
    <id>http://foojolt.github.io/2016/03/07/solr-basics/</id>
    <published>2016-03-07T03:07:14.000Z</published>
    <updated>2016-04-14T02:28:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;classpath&quot;&gt;&lt;a href=&quot;#classpath&quot; class=&quot;headerlink&quot; title=&quot;classpath&quot;&gt;&lt;/a&gt;classpath&lt;/h3&gt;&lt;p&gt;chinese analysis:&lt;br&gt;add solr/contrib/analysis-extras/lucene-libs/* to solr/server/solr-webapp/webapp/WEB-INF/lib&lt;/p&gt;
&lt;h3 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class=&quot;headerlink&quot; title=&quot;命令行&quot;&gt;&lt;/a&gt;命令行&lt;/h3&gt;&lt;p&gt;./solr-5.5.0/bin/solr delete -c fslink&lt;br&gt;./solr-5.5.0/bin/solr create_core -c fslink -d fslink-solr-core/&lt;/p&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h3&gt;&lt;p&gt;基本概念：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Document：代表一篇文档，相当于数据表的一行记录
Field：文档的属性，相当于数据表的列。一个Document包含一个或多个列。
Index：索引，这里指倒排索引，一个 Index包含一个或多个 Document
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Schema：在索引Document之前，需要给出一个schema.xml文件，用于描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Document有哪些Fields，类型是什么
哪个Fields是主键
哪些Fields是必须的
如何索引和查询Fields
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Field的类型：支持自定义类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;float,double,long,date,text
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义一个Field：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name：名称
type：类型
indexed：是否加入倒排索引
store：是否保存原文
multiValued：是否包含多值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Analysis过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;indexed：true 的Fields，都要经过一系列的分词、过滤等过程。也只有index过的field，才能参与搜索
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是否保存：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;保存Fields的原始内容（而不是Analysis之后的值）,会增加索引文件的大小，从而降低查询速度。
一个 indexed:false 的字段，也可以 stored: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与 lucene的关系：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lucene是solr的内核引擎
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;core:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solr core 代表一堆的配置文件（solrconfig.xml schema.xml）、 事务处理的log、 以及索引文件。 多个core可以加载到同一个solr实例中。 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Solr的查询语法&quot;&gt;&lt;a href=&quot;#Solr的查询语法&quot; class=&quot;headerlink&quot; title=&quot;Solr的查询语法&quot;&gt;&lt;/a&gt;Solr的查询语法&lt;/h3&gt;&lt;p&gt;基本的匹配：一个、多个关键词，多个Field匹配，多个条件组合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title:foo
title: &amp;quot;foo bar&amp;quot;
title: &amp;quot;foo bar&amp;quot; AND body: &amp;quot;fox&amp;quot;
( title: foo ADN body: fox ) OR title:fox
title:foo and -title:fox
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模糊匹配：* 表示0个或多个任意字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title:foo*
title:foo*bar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;距离匹配：两个单词的距离差4个单词以内，需要Solr DisMax 或 eDisMax 查询分析器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;title:&amp;quot;foo bar&amp;quot;~4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;范围匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mod_date:[ 201301 TO 201407 ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Boosts: 可以人为设定哪个关键词更重要，影响结果文档的排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(title:foo OR title:bar)^1.5 (body:foo OR body:bar)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他与lucene之外的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;field:[* TO 100]
field:[100 TO *]
field:[* TO *]
-inStock:false 只包含一个非条件
-field:[* TO *] 某个field没有值
_val_:&amp;quot;recip(rord(myfield),1,2,3)&amp;quot; 指定查询函数
_query_:&amp;quot;{!dismax qf=myfield}how now brown cow&amp;quot; 指定query parser
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;实例研究&quot;&gt;&lt;a href=&quot;#实例研究&quot; class=&quot;headerlink&quot; title=&quot;实例研究&quot;&gt;&lt;/a&gt;实例研究&lt;/h3&gt;&lt;p&gt;启动一个样例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/solr -e techproducts
这个命令启动了solr:8983，并将一些文档加入索引
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置文件地址： example/techproducts/solr/techproducts/conf/managed-schema&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bin/solr status 查看状态

cd example/exampledocs
java -Dc=techproducts -jar post.jar sd500.xml 本地索引文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两种方式添加索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP
Native client
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询：可以指定获取那些字段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8983/solr/techproducts/select?q=sd500&amp;amp;wt=json
http://localhost:8983/solr/techproducts/select?q=inStock:false&amp;amp;wt=json&amp;amp;fl=id,name
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;solrconfig.xml 配置dataDir requestHandler cache等（包括DefaultSearchField的配置）
managed-schema 定义schema，支持动态字段，支持copy-field
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;点击solr admin界面上的 optimize， 做了什么事情？&lt;/li&gt;
&lt;li&gt;那几个缓存是什么意思？ &lt;a href=&quot;http://www.solrtutorial.com/solrconfig-xml.html#cache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;solrconfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;facet 查询的概念, 以及其他的查询方式？&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://solr-vs-elasticsearch.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Solr ElasticSearch对比&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.solrtutorial.com/solr-query-syntax.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Toturial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;end&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;classpath&quot;&gt;&lt;a href=&quot;#classpath&quot; class=&quot;headerlink&quot; title=&quot;classpath&quot;&gt;&lt;/a&gt;classpath&lt;/h3&gt;&lt;p&gt;chinese analysis:&lt;br&gt;add solr/contrib/anal
    
    </summary>
    
    
      <category term="solr" scheme="http://foojolt.github.io/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>Solr Facet</title>
    <link href="http://foojolt.github.io/2016/03/07/solr-facet/"/>
    <id>http://foojolt.github.io/2016/03/07/solr-facet/</id>
    <published>2016-03-07T03:07:14.000Z</published>
    <updated>2016-03-08T02:02:26.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;Facet是Solr的高级搜索功能之一，Solr作者给出的定义是导航(Guided Navigation)、参数化查询(Paramatic Search)。 Facet的主要好处是在搜索的同时， 可以按照Facet条件进行分组统计， 给出导航信息，改善搜索体验.&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;Facet是Solr的高级搜索功能之一，Solr作者给出的定义是导航(Guided Navigation)、参数化查询(Paramatic 
    
    </summary>
    
    
      <category term="solr" scheme="http://foojolt.github.io/tags/solr/"/>
    
      <category term="facet" scheme="http://foojolt.github.io/tags/facet/"/>
    
  </entry>
  
  <entry>
    <title>Solr Cache</title>
    <link href="http://foojolt.github.io/2016/03/07/solr-cache/"/>
    <id>http://foojolt.github.io/2016/03/07/solr-cache/</id>
    <published>2016-03-07T03:07:14.000Z</published>
    <updated>2016-03-21T09:30:19.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;三种类型的缓存：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filter-query-cache, query-cache, document-cache
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个query cache缓存占用内存估计： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查询字符串本身占 80 byte
平均每个查询返回 10000 个结果，每个结果就是 8 byte（document id）, ~ 80KB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个 filter cache缓存占用内存估计： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查询字符串本身占 80 byte
假设共有100万偏文档，用一个bit表示一个文档，需要 100万/8 = 125 KB
保存1000个fq缓存，需要 120MB内存
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;filter-cache&quot;&gt;&lt;a href=&quot;#filter-cache&quot; class=&quot;headerlink&quot; title=&quot;filter cache&quot;&gt;&lt;/a&gt;filter cache&lt;/h3&gt;&lt;p&gt;假设有filter query查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/select?q=velvet+pants&amp;amp;fq=category:apparel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与组合查询的区别：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/select?q=(velvet+pants)+AND+category:apparel
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;fq 本身不会改变最终排序结果，而AND查询会&lt;/li&gt;
&lt;li&gt;可以使用 velvet+pants 的 query cache&lt;/li&gt;
&lt;li&gt;可以使用 category:apparel 的 filter cache&lt;/li&gt;
&lt;li&gt;有一个或多个fq存在的情况下，先进行fq&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;documnet cache 就是 document id 到 document 对象的映射。不如 query cache 和 filter cache 那么有效。&lt;/p&gt;
&lt;h3 id=&quot;增加缓存的考虑&quot;&gt;&lt;a href=&quot;#增加缓存的考虑&quot; class=&quot;headerlink&quot; title=&quot;增加缓存的考虑&quot;&gt;&lt;/a&gt;增加缓存的考虑&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OS本身有文件系统缓存，分配的内存是从OS抢过去的&lt;/li&gt;
&lt;li&gt;缓存过大，增加JVM GC压力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;缓存性能&quot;&gt;&lt;a href=&quot;#缓存性能&quot; class=&quot;headerlink&quot; title=&quot;缓存性能&quot;&gt;&lt;/a&gt;缓存性能&lt;/h3&gt;&lt;p&gt;主要指标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cumulative_inserts
cumulative_evictions
cumulative_hitratio
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Solr-空间搜索&quot;&gt;&lt;a href=&quot;#Solr-空间搜索&quot; class=&quot;headerlink&quot; title=&quot;Solr 空间搜索&quot;&gt;&lt;/a&gt;Solr 空间搜索&lt;/h3&gt;&lt;p&gt;GeoHash: 将纬度和经度用二进制表示： 类似二分查找，每次根据落在二分的哪边标记为0或1，越分越细； 错位将经度和纬度放在一起；用类似base64编码。&lt;br&gt;问题：边界点可能hash的字符串会差别较大，搜索时，需要同时检索周边8个点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/solr-spatial-search.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.meituan.com/solr-spatial-search.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;为什么 query cache 和 fq cache 用的缓存记录方式不一样？&lt;/li&gt;
&lt;li&gt;每一种cache的key 和 value ?&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://teaspoon-consulting.com/articles/solr-cache-tuning.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Solr cache tuning&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;三种类型的缓存：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filter-query-cache, query-cache, docum
    
    </summary>
    
    
      <category term="solr" scheme="http://foojolt.github.io/tags/solr/"/>
    
      <category term="cache" scheme="http://foojolt.github.io/tags/cache/"/>
    
  </entry>
  
</feed>
